[comment encoding = UTF-8 /]
[module complexTypeModule('http://www.example.org/ccsl') extends org::ccsl::gen::ocl::elements::namedElement::namedElementModule /]
[import org::gen::ocl::strings::stringModule /]




[template public generateComplexTypeSelect(complexType: ComplexType, filters: OrderedSet(AtomicFilter))]
java::ClassDeclaration.allInstances()->select(class: java::ClassDeclaration |
  [complexType.generateComplexTypeConditions(null, 'class', filters, false, false) /]
)->union(
  java::InterfaceDeclaration.allInstances()->select(interface: java::InterfaceDeclaration |
    [complexType.generateComplexTypeConditions(null, 'interface', filters, false, false) /]
  )
)
[/template]


[query public getAllComplexTypeConditions(complexType: ComplexType, contextElement: Element, varName: String, filters: OrderedSet(AtomicFilter), exactMatch: Boolean): Set(String) =
Set(String){
  	complexType.generateFieldsConditions(contextElement, varName, filters, exactMatch),
	complexType.generateMethodsConditions(contextElement, varName, filters, exactMatch)
}
->select(condition: String | condition.trim().size() > 0)
->union(complexType.getAllNamedElementConditions(contextElement, varName, filters, exactMatch))
/]

[template public generateComplexTypeConditions(element: Element, contextElement: Element, varName: String, filters: OrderedSet(AtomicFilter), exactMatch: Boolean, typeCheck: Boolean) ? (element.oclIsTypeOf(ComplexType)) post(trim())]
[if typeCheck]
[for (javaModel: String | Set(String){'ClassDeclaration', 'InterfaceDeclaration'}) separator('  or \n')]
[let conditions: Set(String) = element.oclAsType(ComplexType).getAllComplexTypeConditions(contextElement, varName.concat('.oclAsType(').concat(javaModel).concat(')'), filters, exactMatch)]
( -- ComplexType Conditions
  [varName /].oclIsKindOf(ClassDeclaration)[if conditions->size() > 0] and 
[for (condition: String | conditions) separator('  and \n')]
  [condition.printStringWithIdentation() /]
[/for][/if]
 ) -- End ComplexType Conditions
[/let][/for]
[else]
( -- ComplexType Conditions
[for (condition: String | element.oclAsType(ComplexType).getAllComplexTypeConditions(contextElement, varName, filters, exactMatch)) separator(' and \n')]
  [condition.printStringWithIdentation() /][/for]

) -- End ComplexType Conditions
[/if]
[/template]



[template private generateFieldsConditions(complexType: ComplexType, contextElement: Element, varName: String, filters: OrderedSet(AtomicFilter), exactMatch: Boolean)]
[if not complexType.fields->oclIsUndefined()]
[comment complexType.generateGenericMultivaluedAttributeCondition(contextElement, varName, filters, exactMatch, true, complexType.fields, 'bodyDeclarations',complexType.generateValidName('class').concat('_fields'), complexType.generateValidName('class').concat('_fieldToSelect')) /][/if]
[/template]


[template private generateMethodsConditions(complexType: ComplexType, contextElement: Element, varName: String, filters: OrderedSet(AtomicFilter), exactMatch: Boolean)]
[comment complexType.generateGenericMultivaluedAttributeCondition(contextElement, varName, filters, exactMatch, true, complexType.methods, 'bodyDeclarations', complexType.generateValidName('class').concat('_methods'), complexType.generateValidName('class').concat('_methodToSelect')) /]
[/template]

[template public test(complexType: ComplexType) overrides test]
[super /]
ComplexType
  [complexType.fields.test() /]
  [complexType.methods.test() /]
[/template]
