[comment encoding = UTF-8 /]
[module stringConcatenationOperations('http://www.example.org/ccsl')]

[import org::ccsl::gen::ocl::commom::stringUtils /]
[import org::ccsl::gen::ocl::commom::OclVariableNameGenerator /]
[import org::ccsl::gen::ocl::commom::infixExpressionInfer /]


[query public getStringConcatenationMatchingMetaclasses(strConcat: StringConcatenation): OrderedSet(String)=
  OrderedSet(String){'InfixExpression'}
/]

[query public getStringConcatenationConditions(strConcat: StringConcatenation, varname: String, typecheck: Boolean): OrderedSet(String) = 
let newVarname: String = varname.printVarname(typecheck, 'InfixExpression') in
let conditions: OrderedSet(String) =  strConcat.getStringConcatenationConditions(newVarname, false)
->append(strConcat.generatesStringConcatenationCheckerWhenInfixExpression(newVarname))
->select(s | s.trim().size() > 0) in
if typecheck then
  OrderedSet(String){varname.printKindOfCondition('InfixExpression')}->addAll(conditions)
else
  conditions
endif
/]

[template public generatesStringConcatenationCheckerWhenInfixExpression(strConcat: StringConcatenation, varname: String)]
[strConcat.generatesDeepCollectorForInfixExpression(varname, strConcat.getOclName().concat('AllElements')) /]
[strConcat.generatesInferInfexExpressionCheckerForString(strConcat.getOclName().concat('AllElements')) /]
[/template]

[template public generatesStringConcatenationCheckerWhenAssignment(strConcat: StringConcatenation, varname: String)]
[let accessName: String = strConcat.getOclName().concat('Access')]
[let typeName: String = strConcat.getOclName().concat('Type')]
let [accessName /]: OclAny = if [varname /].leftHandSide.oclIsKindOf(SingleVariableAccess) then
  [varname /].leftHandSide
else if [varname /].leftHandSide.oclIsKindOf(ArrayAcess) then
  [varname /].leftHandSide.oclAsType(ArrayAccess).array
else
  null
endif endif in (not [accessName /].oclIsUndefined()) and
let [typeName /]: NamedElement = if [accessName /].oclIsKindOf(SingleVariableAccess) and [accessName /].oclAsType(SingleVariableAccess).variable.oclIsKindOf(SingleVariableDeclaration) then
  [accessName /].oclAsType(SingleVariableAccess).variable.oclAsType(SingleVariableDeclaration).type.type
else if [accessName /].oclIsKindOf(SingleVariableAccess) and [accessName /].oclAsType(SingleVariableAccess).variable.oclIsKindOf(VariableDeclarationFragment) then
  [accessName /].oclAsType(SingleVariableAccess).variable.oclAsType(VariableDeclarationFragment).variablesContainer.type.type
else if [accessName /].oclIsKindOf(MethodInvocation) and [accessName /].oclAsType(MethodInvocation).method.oclIsKindOf(MethodDeclaration) then
  [accessName /].oclAsType(MethodInvocation).method.oclAsType(MethodDeclaration).returnType.type
else
  null
endif endif in
[typeName /].package->asOrderedSet()->closure(package)->reverse()->iterate(p: Package; fullName: String = '' |
  fullName.concat(p.name).concat('.')
).concat([typeName /].name) = 'java.lang.String'[/let][/let]
[/template]
