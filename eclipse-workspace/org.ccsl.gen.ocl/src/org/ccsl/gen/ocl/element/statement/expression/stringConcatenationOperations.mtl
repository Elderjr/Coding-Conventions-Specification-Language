[comment encoding = UTF-8 /]
[module stringConcatenationOperations('http://www.example.org/ccsl')]
[import org::ccsl::gen::ocl::element::statement::expression::infixExpressionOperations /]
[import org::ccsl::gen::ocl::commom::stringUtils /]


[query public getStringConcatenationConditions(strConcat: StringConcatenation, varname: String, typecheck: Boolean): OrderedSet(String) = 
let newVarname: String = varname.printVarname(typecheck, 'InfixExpression') in
let conditions: OrderedSet(String) =  strConcat.getInfixConditions(newVarname, false)
->append(strConcat.generatesConditionToCheckStringConcat(newVarname))
->select(s | s.trim().size() > 0) in
if typecheck then
  OrderedSet(String){varname.printKindOfCondition('InfixExpression')}->addAll(conditions)
else
  conditions
endif
/]

[template private generatesConditionToCheckStringConcat(strConcat: StringConcatenation, varName: String)]
[strConcat.generatesCollectAllStatement(varName) /]->exists(stringStatement | 
  ([strConcat.isStringTypeClassInstanceDeclaration('stringStatement') /]) or
  ([strConcat.isStringTypeMethodInvocation('stringStatement') /]) or
  ([strConcat.isStringTypeVariableAccess('stringStatement') /]) or
  ([strConcat.isStringTypeLiteral('stringStatement') /])
[/template]

[template private generatesCollectAllStatement(strConcat: StringConcatenation, varName: String)]
[varName /].extendedOperands->append([varName /].leftOperand)->append([varName /].rightOperand)->closure(x | 
  if x.oclIsKindOf(ParenthesizedExpression) then x.oclAsType(ParenthesizedExpression).expression 
  else if x.oclIsKindOf(InfixExpression) then x.oclAsType(InfixExpression).extendedOperands->append(x.oclAsType(InfixExpression).leftOperand)->append(x.oclAsType(InfixExpression).rightOperand)
  else Set(OclAny){x} endif endif
)
[/template]

[template private isStringTypeClassInstanceDeclaration(strConcat: StringConcatenation, varName: String)]
[varName /].oclIsKindOf(ClassInstanceCreation) and [varName /].oclAsType(ClassInstanceCreation).type.type.name = 'String'
[/template]

[template private isStringTypeMethodInvocation(strConcat: StringConcatenation, varName: String)]
[varName /].oclIsKindOf(MethodInvocation) and 
(not [varName /].oclAsType(MethodInvocation).method.oclAsType(MethodDeclaration).returnType.oclIsUndefined()) and
[varName /].oclAsType(MethodInvocation).method.oclAsType(MethodDeclaration).returnType.type.name = 'String' 
[/template]

[template private isStringTypeLiteral(strConcat: StringConcatenation, varName: String)]
[varName /].oclIsKindOf(StringLiteral) 
[/template]

[template private isStringTypeVariableAccess(strConcat: StringConcatenation, varName: String)]
[varName /].oclIsKindOf(SingleVariableAccess) and 
(let accessType: String = if [varName /].oclAsType(SingleVariableAccess).variable.oclIsKindOf(VariableDeclarationFragment) then
  [varName /].oclAsType(SingleVariableAccess).variable.oclAsType(VariableDeclarationFragment).variablesContainer.type.type.name
else if [varName /].oclAsType(SingleVariableAccess).variable.oclIsKindOf(SingleVariableDeclaration) then
  [varName /].oclAsType(SingleVariableAccess).variable.oclAsType(SingleVariableDeclaration).type.type.name
else
  ''
endif endif in accessType = 'String')
[/template]