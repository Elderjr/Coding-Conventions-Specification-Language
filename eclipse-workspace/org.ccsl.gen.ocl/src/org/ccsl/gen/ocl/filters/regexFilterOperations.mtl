[comment encoding = UTF-8 /]
[module regexFilterOperations('http://www.example.org/ccsl')]
[import org::ccsl::gen::ocl::commom::OclVariableNameGenerator /]
[import org::ccsl::gen::ocl::element::statement::literalValueOperations /]
[template public generatesRegexFilterConditions(regexFilter: RegexMatch, target: Element)]
### RegexMatch is not supported for the type [target.eClass().name /] ###
[/template]

[template public generatesRegexFilterConditions(regexFilter: RegexMatch, target: NamedElement)]
[target.generateOclVariableName() /].name.matches('[regexFilter.regex /]')
[/template]

[template private generatesRegexFilterConditions(regexFilter: RegexMatch, target: ComplexType)]
[let packageHierarchy: String = target.generateOclVariableName().concat('PackageHierarchy')]
let [packageHierarchy /]: Sequence(Package) = if [target.generateOclVariableName() /].oclIsKindOf(ClassDeclaration) then
  [target.generateOclVariableName() /].oclAsType(ClassDeclaration).package->asSequence()->closure(package)->asSequence()
else
  [target.generateOclVariableName() /].oclAsType(InterfaceDeclaration).package->asSequence()->closure(package)->asSequence()
endif in (
  Sequence{1 .. [packageHierarchy /]->size() }->iterate(i: Integer; fullName: String = '' | 
    	fullName.concat([packageHierarchy /]->at([packageHierarchy /]->size() - i + 1).name).concat('.')
  ).concat([target.generateOclVariableName() /].oclAsType(BodyDeclaration).name).matches('[regexFilter.regex /]')
)
[/let]
[/template]

[template private generatesRegexFilterConditions(regexFilter: RegexMatch, target: JavaClass)]
[let packageHierarchy: String = target.generateOclVariableName().concat('PackageHierarchy')]
let [packageHierarchy /]: Sequence(Package) = [target.generateOclVariableName() /].oclAsType(ClassDeclaration).package->asSequence()->closure(package)->asSequence() in (
  Sequence{1 .. [packageHierarchy /]->size() }->iterate(i: Integer; fullName: String = '' | 
    	fullName.concat([packageHierarchy /]->at([packageHierarchy /]->size() - i + 1).name).concat('.')
  ).concat([target.generateOclVariableName() /].oclAsType(BodyDeclaration).name).matches('[regexFilter.regex /]')
)
[/let]
[/template]

[template public generatesRegexFilterConditions(regexFilter: RegexMatch, target: LiteralValue)]
[let varName:String = target.generateOclVariableName()]
[if (not target.type.oclIsUndefined()) and (target.type.name = 'string')]
[varName /].oclAsType(StringLiteral).[target.getValueFieldName() /].matches('"[regexFilter.regex /]"')[elseif target.type.oclIsUndefined()]
[for (type: String | target.getAllLiteralMetaclasses()) separator('or')]
([varName /].oclIsKindOf([type /]) and [varName /].[target.getValueFieldNameByJavaMetaclassName(type) /].matches('[regexFilter.regex /]'))[/for]
[/if][/let]
[/template]
