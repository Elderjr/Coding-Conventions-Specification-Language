[comment encoding = UTF-8 /]
[module closureOperationFilterModule('http://www.example.org/ccsl')]
[import org::ccsl::gen::ocl::commom::uniqueNameGeneratorModule /]
[import org::ccsl::gen::ocl::dispatchers::generatesElementConditionsDispatcher /]
[import org::ccsl::gen::ocl::commom::elementUtils /]


[query private isIntegerSetted(x: Integer): Boolean = 
  (not x.oclIsUndefined()) and x <> -1
/]


[template public generatesClosureOperationFilterConditions(filter: ClosureFilter, target: Element)]
let [filter.subject.getUniqueOclName() /]:ASTNode = [target.getUniqueOclName() /] in
[filter.subject.generatesConditions(filter.subject.getUniqueOclName(), true) /] and
[filter.generatesClosureSet(filter.subject, filter.closureElement, filter.subject.getUniqueOclName(), 'closureSet') /]
[filter.generatesSubClosureSet('closureSet') /][filter.generatesClosureSetCondition('closureSet') /]
[/template]

[template private generatesSubClosureSet(filter: ClosureFilter, setOclVarname: String) ? (filter.minDepth.isIntegerSetted() and filter.maxDepth.isIntegerSetted())]
let [setOclVarname /]: OrderedSet(ASTNode) = [setOclVarname /]->subOrderedSet([filter.minDepth /], [filter.maxDepth /]) in 
[/template]

[template private generatesSubClosureSet(filter: ClosureFilter, setOclVarname: String) ? (filter.minDepth.isIntegerSetted() and not filter.maxDepth.isIntegerSetted())]
let [setOclVarname /]: OrderedSet(ASTNode) = [setOclVarname /]->subOrderedSet([filter.minDepth /], [setOclVarname /]->size()) in 
[/template]

[template private generatesSubClosureSet(filter: ClosureFilter, setOclVarname: String) ? ((not filter.minDepth.isIntegerSetted()) and filter.maxDepth.isIntegerSetted())]
let [setOclVarname /]: OrderedSet(ASTNode) = [setOclVarname /]->subOrderedSet(1, [filter.maxDepth /]) in 
[/template]

[template private generatesClosureSetCondition(filter: ClosureFilter, setOclVarname: String)]
[setOclVarname /]->exists([filter.closureElement.getUniqueOclName() /]:ASTNode |
  [filter.closureElement.generatesConditions(filter.closureElement.getUniqueOclName(), true) /]
)
[/template]

[template private generatesClosureSet(f: ClosureFilter, container: Element, field: Element, containerOclVarname: String, relation: String) /]

[template private generatesClosureSet(f: ClosureFilter, container: MethodInvocation, field: Element, containerOclVarname: String, setOclVarname: String) ? (container.getRelationName(field) = 'from')]
let [setOclVarname /]: OrderedSet(ASTNode) = [containerOclVarname /].oclAsType(MethodInvocation).expression->closure(node: ASTNode |
  if(node.oclIsKindOf(ParenthesizedExpression)) then
    node.oclAsType(ParenthesizedExpression).expression
  else if(node.oclIsKindOf(MethodInvocation)) then
    node.oclAsType(MethodInvocation).expression
  else if(node.oclIsKindOf(SingleVariableAccess)) then
    node.oclAsType(SingleVariableAccess).qualifier
  else if(node.oclIsKindOf(TypeAccess)) then
    node.oclAsType(TypeAccess).qualifier
  else if(node.oclIsKindOf(TypeLiteral)) then
    node.oclAsType(TypeLiteral).type
  else
    null
  endif endif endif endif endif
)
[/template]

[template private generatesClosureSet(f: ClosureFilter, container: InfixExpression, field: Element, containerOclVarname: String, setOclVarname: String) ? (container.getRelationName(field) = 'operands')]
let [setOclVarname /]: OrderedSet(ASTNode) = [containerOclVarname /].oclAsType(InfixExpression).extendedOperands
->append([containerOclVarname /].oclAsType(InfixExpression).leftOperand)
->append([containerOclVarname /].oclAsType(InfixExpression).rightOperand)
->closure(node: ASTNode |
  if (node.oclIsKindOf(ParenthesizedExpression)) then
    node.oclAsType(ParenthesizedExpression).expression
  else if (node.oclIsKindOf(InfixExpression)) then
    node.oclAsType(InfixExpression).extendedOperands
    ->append(node.oclAsType(InfixExpression).leftOperand)
    ->append(node.oclAsType(InfixExpression).rightOperand)
  else
    null
  endif endif
) in
[/template]
