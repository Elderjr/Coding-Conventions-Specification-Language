[comment encoding = UTF-8 /]
[module methodInvocationOperations('http://www.example.org/ccsl')]

[import org::ccsl::gen::ocl::commom::stringUtils /]
[import org::ccsl::gen::ocl::commom::elementUtils /]
[import org::ccsl::gen::ocl::commom::fieldWritterConditionsModule /]

[query public getMethodInvocationMatchingMetaclasses(methodInv: MethodInvocation): OrderedSet(String) = 
  if methodInv.mustWriteConditionFor('from') then
    OrderedSet(String){'MethodInvocation'}
  else
    OrderedSet(String){'MethodInvocation', 'SuperMethodInvocation'}
  endif
/]

[template public writeMethodInvocationTypecheckCondition(methodInv: MethodInvocation, varname: String, typecheck: Boolean, metaclass: String) ? (typecheck)]
([for (javaMetaclass: String | methodInv.getMethodInvocationMatchingMetaclasses()) separator (' or ')]
[varname /].oclIsKindOf([javaMetaclass /])[/for])
[/template]

[template public writeToCondition(methodInv: MethodInvocation, varname: String, metaclass: String) ? (methodInv.mustWriteConditionFor('elementAccessed') and methodInv.isMetaclassInMatchingMetaclasses(metaclass))]
[methodInv.generatesMonovaluedFieldConditions(methodInv.elementAccessed, varname, 'method', 'MethodDeclaration') /]
[/template]

[template public writeToCondition(methodInv: MethodInvocation, varname: String, metaclass: String) ? (methodInv.mustWriteConditionFor('elementAccessed') and not methodInv.isMetaclassInMatchingMetaclasses(metaclass))]
[methodInv.generatesMonovaluedFieldConditions(methodInv.elementAccessed, varname, 'method', 'MethodDeclaration', methodInv.getMethodInvocationMatchingMetaclasses()) /]
[/template]

[template public writeFromCondition(methodInv: MethodInvocation, varname: String, metaclass: String) ? (methodInv.mustWriteConditionFor('from') and methodInv.isMetaclassInMatchingMetaclasses(metaclass))]
[methodInv.generatesMonovaluedFieldConditions(methodInv.from, varname, 'expression', 'ASTNode', methodInv.getMethodInvocationMatchingMetaclasses()) /]
[/template]

[template public writeFromCondition(methodInv: MethodInvocation, varname: String, metaclass: String) ? (methodInv.mustWriteConditionFor('from') and not methodInv.isMetaclassInMatchingMetaclasses(metaclass))]
[methodInv.generatesMonovaluedFieldConditions(methodInv.from, varname, 'expression', 'ASTNode', methodInv.getMethodInvocationMatchingMetaclasses()) /]
[/template]

[template public writeArgsCondition(methodInv: MethodInvocation, varname: String, metaclass: String) ? (methodInv.mustWriteConditionFor('args') and methodInv.isMetaclassInMatchingMetaclasses(metaclass))]
let args: OrderedSet(ASTNode) = [varname /].arguments->collect(arg: ASTNode |
  arg->closure(v: ASTNode | if v.oclIsKindOf(ParenthesizedExpression) then
    v.oclAsType(ParenthesizedExpression).expression
  else
    v
  endif)
) in
[methodInv.generatesSetConditions('args', methodInv.args, 'ASTNode') /]
[/template]

[template public writeArgsCondition(methodInv: MethodInvocation, varname: String, metaclass: String) ? (methodInv.mustWriteConditionFor('args') and not methodInv.isMetaclassInMatchingMetaclasses(metaclass))]
let args: OrderedSet(ASTNode) = if [varname /].oclIsKindOf(MethodInvocation) then
  [varname /].oclAsType(MethodInvocation).arguments
elseif [varname /].oclIsKindOf(SuperMethodInvocation) then
  [varname /].oclAsType(SuperMethodInvocation).arguments
else
  null
endif in (not args->oclIsUndefined()) and
let args: OrderedSet(ASTNode) = args->collect(arg: ASTNode |
  arg->closure(v: ASTNode | if v.oclIsKindOf(ParenthesizedExpression) then
    v.oclAsType(ParenthesizedExpression).expression
  else
    v
  endif)
) in
[methodInv.generatesSetConditions('args', methodInv.args, 'ASTNode') /]
[/template]