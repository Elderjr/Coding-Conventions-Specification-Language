[comment encoding = UTF-8 /]
[module methodInvocationOperations('http://www.example.org/ccsl')]
[import org::ccsl::gen::ocl::element::statement::statementOperations /]
[import org::ccsl::gen::ocl::commom::walkHelperModule /]
[import org::ccsl::gen::ocl::commom::stringUtils /]
[import org::ccsl::gen::ocl::commom::elementUtils /]
[import org::ccsl::gen::ocl::commom::genericFieldConditionsGenerator /]

[query public getMethodInvocationMatchingMetaclasses(methodInv: MethodInvocation): OrderedSet(String)= 
  OrderedSet(String){'MethodInvocation', 'SuperMethodInvocation'}
/]

[query public getMethodInvocationConditions(methodInv: MethodInvocation, varname: String, typecheck: Boolean, metaclass: String): OrderedSet(String) =
let void: OclVoid = methodInv.addElementAsVisited(metaclass) in
let concreteMetaclass: String = methodInv.getConcreteElementMetaclass(metaclass) in
let completeVarname: String = methodInv.getCompleteElementVarname(varname, metaclass) in
OrderedSet(String) {
  methodInv.writeMethodInvocationTypecheckCondition(varname, typecheck, metaclass),
  methodInv.writeToCondition(completeVarname, concreteMetaclass),
  methodInv.writeFromCondition(completeVarname, concreteMetaclass),
  methodInv.writeArgsCondition(completeVarname, concreteMetaclass)
}->select(s | s.trim().size() > 0)
->addAll(methodInv.getStatementConditions(completeVarname, false, concreteMetaclass))
/]

[template public writeMethodInvocationTypecheckCondition(methodInv: MethodInvocation, varname: String, typecheck: Boolean, metaclass: String) ? (typecheck)]
([varname /].oclIsKindOf(MethodInvocation) or [varname /].oclIsKindOf(SuperMethodInvocation))
[/template]

[template public writeToCondition(methodInv: MethodInvocation, varname: String, metaclass: String) ? (methodInv.mustWriteConditionFor('elementAccessed') and methodInv.isMetaclassInMatchingMetaclasses(metaclass))]
[methodInv.generatesMonovaluedFieldConditions(methodInv.elementAccessed, varname, 'method', 'MethodDeclaration') /]
[/template]

[template public writeToCondition(methodInv: MethodInvocation, varname: String, metaclass: String) ? (methodInv.mustWriteConditionFor('elementAccessed') and not methodInv.isMetaclassInMatchingMetaclasses(metaclass))]
[methodInv.generatesMonovaluedFieldConditions(methodInv.elementAccessed, varname, 'method', 'MethodDeclaration', methodInv.getMethodInvocationMatchingMetaclasses()) /]
[/template]

[template public writeFromCondition(methodInv: MethodInvocation, varname: String, metaclass: String) ? (methodInv.mustWriteConditionFor('from') and methodInv.isMetaclassInMatchingMetaclasses(metaclass))]
[methodInv.generatesMonovaluedFieldConditions(methodInv.from, varname, 'expression', 'ASTNode', methodInv.getMethodInvocationMatchingMetaclasses()) /]
[/template]

[template public writeFromCondition(methodInv: MethodInvocation, varname: String, metaclass: String) ? (methodInv.mustWriteConditionFor('from') and not methodInv.isMetaclassInMatchingMetaclasses(metaclass))]
[methodInv.generatesMonovaluedFieldConditions(methodInv.from, varname, 'expression', 'ASTNode', methodInv.getMethodInvocationMatchingMetaclasses()) /]
[/template]

[template public writeArgsCondition(methodInv: MethodInvocation, varname: String, metaclass: String) ? (methodInv.mustWriteConditionFor('args') and methodInv.isMetaclassInMatchingMetaclasses(metaclass))]
let args: OrderedSet(ASTNode) = [varname /].arguments->collect(arg: ASTNode |
  arg->closure(v: ASTNode | if v.oclIsKindOf(ParenthesizedExpression) then
    v.oclAsType(ParenthesizedExpression).expression
  else
    v
  endif)
) in
[methodInv.generatesSetConditions('args', methodInv.args, 'ASTNode') /]
[/template]

[template public writeArgsCondition(methodInv: MethodInvocation, varname: String, metaclass: String) ? (methodInv.mustWriteConditionFor('args') and not methodInv.isMetaclassInMatchingMetaclasses(metaclass))]
let args: OrderedSet(ASTNode) = if [varname /].oclIsKindOf(MethodInvocation) then
  [varname /].oclAsType(MethodInvocation).arguments
elseif [varname /].oclIsKindOf(SuperMethodInvocation) then
  [varname /].oclAsType(SuperMethodInvocation).arguments
else
  null
endif in (not args->oclIsUndefined()) and
let args: OrderedSet(ASTNode) = args->collect(arg: ASTNode |
  arg->closure(v: ASTNode | if v.oclIsKindOf(ParenthesizedExpression) then
    v.oclAsType(ParenthesizedExpression).expression
  else
    v
  endif)
) in
[methodInv.generatesSetConditions('args', methodInv.args, 'ASTNode') /]
[/template]