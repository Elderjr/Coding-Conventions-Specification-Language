[comment encoding = UTF-8 /]
[module complexTypeOperations('http://www.example.org/ccsl')]

[import org::ccsl::gen::ocl::commom::stringUtils /]
[import org::ccsl::gen::ocl::commom::elementUtils /]
[import org::ccsl::gen::ocl::commom::uniqueNameGeneratorModule /]
[import org::ccsl::gen::ocl::commom::walkHelperModule /]
[import org::ccsl::gen::ocl::commom::fieldWritterConditionsModule /]
[import org::ccsl::gen::ocl::dispatchers::generalElementWritterConditionsModule /]



[template public generatesComplexTypeTypecheckCondition(complexType: ComplexType, varname: String, typecheck: Boolean, metaclass: String) ? (typecheck)]
([varname /].oclIsKindOf(ClassDeclaration) or [varname /].oclIsKindOf(InterfaceDeclaration) or [varname /].oclIsKindOf(AnonymousClassDeclaration))
[/template]

[query private mustWriteGetBodyDeclarations(complexType: ComplexType): Boolean =
  complexType.mustWriteConditionFor('fields') or complexType.mustWriteConditionFor('methods') or complexType.mustWriteConditionFor('constructors') /]
[template public writeGetBodyDeclarations(complexType: ComplexType, varname: String, metaclass: String) ? (metaclass <> 'ClassDeclaration' and metaclass <> 'InterfaceDeclaration' and complexType.mustWriteGetBodyDeclarations())]
let bodyDeclarations: OrderedSet(ASTNode) = if [varname /].oclIsKindOf(AbstractTypeDeclaration) then
  [varname /].oclAsType(AbstractTypeDeclaration).bodyDeclarations
elseif [varname /].oclIsKindOf(AnonymousClassDeclaration) then
  [varname /].oclAsType(AnonymousClassDeclaration).bodyDeclarations
else
  null
endif in bodyDeclarations <> null
[/template]

[template public writeGetBodyDeclarations(complexType: ComplexType, varname: String, metaclass: String) ? ((not complexType.oclIsTypeOf(ComplexType)) and complexType.mustWriteGetBodyDeclarations() )]
let bodyDeclarations: OrderedSet(ASTNode) = [varname /].bodyDeclarations in bodyDeclarations <> null
[/template]

[template public writeFieldsCondition(complexType: ComplexType, varname: String, metaclass: String) ? (complexType.mustWriteConditionFor('fields'))]
let fields: OrderedSet(VariableDeclarationFragment) = bodyDeclarations->collect(field: ASTNode | if field.oclIsKindOf(FieldDeclaration) then
  field.oclAsType(FieldDeclaration).fragments
else
  null
endif
)->select(field: ASTNode | field <> null)->flatten() in
[complexType.generatesSetConditions('fields', complexType.fields, 'VariableDeclarationFragment') /]
[/template]

[template public writeMethodsCondition(complexType: ComplexType, varname: String, metaclass: String) ? (complexType.mustWriteConditionFor('methods'))]
let methods: OrderedSet(MethodDeclaration) = bodyDeclarations->select(method: ASTNode | method.oclIsKindOf(MethodDeclaration)) in
[complexType.generatesSetConditions('methods', complexType.methods, 'MethodDeclaration') /]
[/template]




