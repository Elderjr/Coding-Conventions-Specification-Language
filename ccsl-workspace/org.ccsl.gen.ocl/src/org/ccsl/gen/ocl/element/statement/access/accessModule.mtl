[comment encoding = UTF-8 /]
[module accessModule('http://www.example.org/ccsl')]

[import org::ccsl::gen::ocl::commom::elementUtils /]
[import org::ccsl::gen::ocl::commom::fieldWritterConditionsModule /]
[import org::ccsl::gen::ocl::commom::stringUtils /]

[query public getAccessMatchingMetaclasses(access: Access): OrderedSet(String)=
  OrderedSet(String){'TypeAccess', 'MethodInvocation', 'SingleVariableAccess'}
/]

[template public writeAccessTypecheckCondition(access: Access, varname: String, typecheck: Boolean, metaclass: String) ? (typecheck and not access.isMetaclassInMatchingMetaclasses(metaclass))]
([for (metaclass: String | access.getAccessMatchingMetaclasses()) separator(' or ')]
[varname.printKindOfCondition(metaclass) /][/for])
[/template]

[template public writeAccessTypecheckCondition(access: Access, varname: String, typecheck: Boolean, metaclass: String) ? (typecheck and access.isMetaclassInMatchingMetaclasses(metaclass))]
[varname.printKindOfCondition(metaclass) /]
[/template]

[template public writeFromCondition(access: Access, varname: String, metaclass: String) ? (access.mustWriteConditionFor('from') and (metaclass = 'SingleVariableAccess' or metaclass = 'TypeAccess'))]
[access.generatesMonovaluedFieldConditions(access.from, varname, 'qualifier', 'ASTNode') /]
[/template]

[template public writeFromCondition(access: Access, varname: String, metaclass: String) ? (access.mustWriteConditionFor('from') and metaclass = 'MethodInvocation')]
[access.generatesMonovaluedFieldConditions(access.from, varname, 'expression', 'ASTNode') /]
[/template]

[template public writeFromCondition(access: Access, varname: String, metaclass: String) ? (access.mustWriteConditionFor('from'))]
[let map: OrderedSet(OrderedSet(String)) = OrderedSet(OrderedSet(String)) {
  OrderedSet(String){'TypeAccess', 'qualifier'},
  OrderedSet(String){'SingleVariableAccess', 'qualifier'},  
  OrderedSet(String){'MethodInvocation', 'expression'}
}]
[access.generatesMonovaluedFieldConditions( access.from, varname, 'ASTNode', map) /]
[/let]
[/template]

[template public writeElementAccessedCondition(access: DataTypeAccess, varname: String, metaclass: String) ? (access.mustWriteConditionFor('elementAccessed') and metaclass = 'TypeAccess')]
let typesAccessed: OrderedSet(ASTNode) = [varname /]->asOrderedSet()->closure(type |
  if type.oclIsKindOf(ArrayType) then
    type.oclAsType(ArrayType).elementType.type
  elseif type.oclIsKindOf(TypeAccess) then
    type.oclAsType(TypeAccess).type
  else
    type
  endif
)->select(type | type <> null) in
[access.generatesSetConditions(access, 'typesAccessed', OrderedSet(Element){access.elementAccessed}, 'ASTNode') /]
[/template]

[template public writeElementAccessedCondition(access: Access, varname: String, metaclass: String) /]

[template public writeElementAccessedCondition(access: VariableAccess, varname: String, metaclass: String)]
[let map: OrderedSet(OrderedSet(String)) = OrderedSet(OrderedSet(String)) {
  OrderedSet(String){'SingleVariableAccess', 'variable'},
  OrderedSet(String){'FieldAccess', 'field.variable'},  
  OrderedSet(String){'SuperFieldAccess', 'field.variable'}
}][access.generatesMonovaluedFieldConditions( access.elementAccessed, varname, 'ASTNode', map) /][/let]
[/template]



