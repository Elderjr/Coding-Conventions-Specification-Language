[comment encoding = UTF-8 /]
[module infixExpressionOperations('http://www.example.org/ccsl')]
[import org::ccsl::gen::ocl::element::statement::statementOperations /]
[import org::ccsl::gen::ocl::commom::stringUtils /]
[import org::ccsl::gen::ocl::commom::elementUtils /]
[import org::ccsl::gen::ocl::commom::genericFieldConditionsGenerator /]
[import org::ccsl::gen::ocl::commom::walkHelperModule /]

[query public getInfixMatchingMetaclasses(infixExp: InfixExpression): OrderedSet(String)= 
  OrderedSet(String){'InfixExpression'}
/]

[query public getInfixConditions(infix: InfixExpression, varname: String, typecheck: Boolean): OrderedSet(String) = 
let void: OclVoid = infix.addElementAsVisited() in
let newVarname: String = varname.printVarname(typecheck, 'InfixExpression') in
let conditions: OrderedSet(String) =  OrderedSet(String){
  infix.generatesConditionForOperator(newVarname),
  infix.generatesConditionForOperands(newVarname)
}
->select(s | s.trim().size() > 0)
->addAll(infix.getStatementConditions(newVarname, false)) in
if typecheck then
  OrderedSet(String){varname.printKindOfCondition('InfixExpression')}->addAll(conditions)
else
  conditions
endif
/]

[template public generatesConditionForOperator(infixExp: InfixExpression, varname: String) ? (not infixExp.operator.oclIsUndefined())]
[if infixExp.operator = '&&']
[varname /].operator = InfixExpressionKind::CONDITIONAL_AND[elseif infixExp.operator = '||']
[varname /].operator = InfixExpressionKind::CONDITIONAL_OR[/if]
[/template]

[template public generatesConditionForOperands(infixExp: InfixExpression, varname: String) ? (infixExp.hasAnyNotClosureRelationField(infixExp.operands))]
let operands: OrderedSet(ASTNode) = leftOperand->asOrderedSet()->append([varname /].rightOperand)->append([varname /].extendedOperands) in
[infixExp.generatesSetConditions('operands', infixExp.operands, 'ASTNode') /]
[/template]

