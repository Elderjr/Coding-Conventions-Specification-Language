[comment encoding = UTF-8 /]
[module infixExpressionOperations('http://www.example.org/ccsl')]
[import org::ccsl::gen::ocl::element::elementOperations /]
[import org::ccsl::gen::ocl::commom::stringUtils /]
[import org::ccsl::gen::ocl::commom::genericFieldConditionsGenerator /]

[query public getInfixMatchingMetaclasses(infixExp: InfixExpression): OrderedSet(String)= 
  OrderedSet(String){'InfixExpression'}
/]

[query public getInfixConditions(infix: InfixExpression, varname: String, typecheck: Boolean): OrderedSet(String) = 
let newVarname: String = varname.printVarname(typecheck, 'InfixExpression') in
let conditions: OrderedSet(String) =  OrderedSet(String){
  infix.generateConditionForOperator(newVarname),
  infix.generateConditionForOperands(newVarname)
}->select(s | s.trim().size() > 0) in
if typecheck then
  OrderedSet(String){varname.printKindOfCondition('InfixExpression')}->addAll(conditions)
else
  conditions
endif
/]

[template public getAllOperandsExpression(infixExp: InfixExpression, varName: String)]
leftOperand->asOrderedSet()->append([varName /].rightOperand)->append([varName /].extendedOperands)
[/template]

[template public generateConditionForOperator(infixExp: InfixExpression, varName: String) ? (not infixExp.operator.oclIsUndefined())]
[varName /].operator = '[infixExp.operator /]'
[/template]

[template public generateConditionForOperands(infixExp: InfixExpression, varname: String) ? (infixExp.operands->size() > 0)]
[infixExp.generatesMultivaluedFieldConditions(varname, infixExp.operands, 'tmpOperands', infixExp.getAllOperandsExpression(varname), 'OclAny') /]
[/template]

