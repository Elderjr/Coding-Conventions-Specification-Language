[comment encoding = UTF-8 /]
[module booleanExpressionModule('http://www.example.org/ccsl')]
[import org::ccsl::gen::ocl::element::statement::expression::operatorExpressionOperations /]
[import org::ccsl::gen::ocl::commom::genericFieldConditionsGenerator /]
[import org::ccsl::gen::ocl::commom::stringUtils /]
[import org::ccsl::gen::ocl::commom::elementUtils /]
[import org::ccsl::gen::ocl::commom::walkHelperModule /]

[query public getBooleanExpressionMatchingJavaMetaclasses(booleanExp: BooleanExpression): OrderedSet(String)=
  if (booleanExp.booleanOperator = BooleanOperator::UNDEFINED) then
    OrderedSet(String){'InfixExpression', 'PrefixExpression'}
  else if (booleanExp.booleanOperator = BooleanOperator::NOT) then
    OrderedSet(String){'PrefixExpression'}
  else
    OrderedSet(String){'InfixExpression'}
  endif endif
/]

[query public getBooleanExpressionConditions(booleanExpression: BooleanExpression, varname: String, typecheck: Boolean, metaclass: String): OrderedSet(String) = 
let void: OclVoid = booleanExpression.addElementAsVisited(metaclass) in
let completeVarname: String = booleanExpression.getCompleteElementVarname(varname, metaclass) in
let concreteMetaclass: String = booleanExpression.getConcreteElementMetaclass(metaclass) in
OrderedSet(String){
  booleanExpression.writeBooleanExpressionTypecheckCondition(varname, typecheck, concreteMetaclass),
  booleanExpression.writeBooleanOperatorCondition(completeVarname, concreteMetaclass)
}->select(s | s.isNotEmpty())
->addAll(booleanExpression.getOperatorExpressionConditions(completeVarname, false, concreteMetaclass))
/]



[template private writeBooleanExpressionTypecheckCondition(booleanExp: BooleanExpression, varname: String, typecheck: Boolean, metaclass: String) ? (typecheck and (metaclass = 'InfixExpression' or metaclass = 'PrefixExpression'))]
[varname /].oclIsKindOf([metaclass /])
[/template]

[template private writeBooleanExpressionTypecheckCondition(booleanExp: BooleanExpression, varname: String, typecheck: Boolean, metaclass: String) ? (typecheck)]
if [varname /].oclIsKindOf(InfixExpression) then
  let booleanInfixExpressionOperators: Set(InfixExpressionKind) = Set(InfixExpressionKind){
    InfixExpressionKind::LESS,
    InfixExpressionKind::GREATER,
    InfixExpressionKind::LESS_EQUALS,
    InfixExpressionKind::GREATER_EQUALS,
    InfixExpressionKind::EQUALS,
    InfixExpressionKind::NOT_EQUALS,
    InfixExpressionKind::CONDITIONAL_AND,
    InfixExpressionKind::CONDITIONAL_OR
  } in booleanInfixExpressionOperators->exists(op | op = [varname /].oclAsType(InfixExpression).operator)
else if [varname /].oclIsKindOf(PrefixExpression) then
  [varname /].oclAsType(PrefixExpression).operator = PrefixExpressionKind::NOT
else
  false
endif endif
[/template]

[template private writeBooleanOperator(booleanOp: BooleanOperator)]
[if (booleanOp = BooleanOperator::AND)]
InfixExpressionKind::CONDITIONAL_AND[elseif (booleanOp = BooleanOperator::EQUAL_TO)]
InfixExpressionKind::EQUALS[elseif (booleanOp = BooleanOperator::GREATER_THAN)]
InfixExpressionKind::GREATER[elseif (booleanOp = BooleanOperator::GREATER_THAN_OR_EQUAL_TO)]
InfixExpressionKind::GREATER_EQUALS[elseif (booleanOp = BooleanOperator::LESS_THAN)]
InfixExpressionKind::LESS[elseif (booleanOp = BooleanOperator::LESS_THAN_OR_EQUAL_TO)]
InfixExpressionKind::LESS_EQUALS[elseif (booleanOp = BooleanOperator::NOT)]
InfixExpressionKind::CONDITIONAL_OR[elseif (booleanOp = BooleanOperator::NOT_EQUAL_TO)]
InfixExpressionKind::NOT_EQUALS[elseif (booleanOp = BooleanOperator::OR)]
InfixExpressionKind::CONDITIONAL_OR[/if]
[/template]

[template private writeBooleanOperatorCondition(booleanExp: BooleanExpression, varname: String, metaclass: String) ? (booleanExp.booleanOperator <> BooleanOperator::UNDEFINED)]
[varname /].operator = [booleanExp.booleanOperator.writeBooleanOperator() /]
[/template]
