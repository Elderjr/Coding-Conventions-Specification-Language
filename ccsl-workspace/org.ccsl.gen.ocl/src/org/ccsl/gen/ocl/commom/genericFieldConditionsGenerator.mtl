[comment encoding = UTF-8 /]
[module genericFieldConditionsGenerator('http://www.example.org/ccsl')]

[import org::ccsl::gen::ocl::dispatchers::generatesElementConditionsDispatcher /]
[import org::ccsl::gen::ocl::commom::uniqueNameGeneratorModule /]
[import org::ccsl::gen::ocl::commom::walkHelperModule /]
[import org::ccsl::gen::ocl::commom::getOclElementReferenceModule /] 
[import org::ccsl::gen::ocl::commom::stringUtils /]
[import org::ccsl::gen::ocl::commom::elementUtils /]

[query private generatesFieldConditions(element: Element, mappedMetaclass: String): String = 
if(mappedMetaclass = 'OclAny' or mappedMetaclass = 'ASTNode') then
  element.generatesConditions(element.getUniqueOclName(), true)
else
  element.generatesConditions(element.getUniqueOclName(), false, mappedMetaclass)
endif
/]

[template public generatesLetIfObject(element: Element, varname: String, mappedFieldName: String, mappedElementMetaclasses: OrderedSet(String), letOclName: String, letType: String)]
let [letOclName /]: [letType /] = [for(metaclass: String | mappedElementMetaclasses) separator('else ')]
if [varname /].oclIsKindOf([metaclass /]) then
  [varname /].oclAsType([metaclass /]).[mappedFieldName /]
[/for]
else
  null
[for (Sequence(Integer){1..mappedElementMetaclasses->size()}) separator(' ')]endif[/for] in
[/template]

[template public generatesLetIfObject(element: Element, varname: String, map: OrderedSet(OrderedSet(String)), letOclName: String, letType: String)]
let [letOclName /]: [letType /] = [for(entry: OrderedSet(String) | map) separator('else ')]
if [varname /].oclIsKindOf([entry->at(1) /]) then
  [varname /].oclAsType([entry->at(1) /]).[entry->at(2) /]
[/for]
else
  null
[for (Sequence(Integer){1..map->size()}) separator(' ')]endif[/for] in
[/template]

[comment Gerar condicoes de atributo monovalorado (apenas uma metaclasse mapeada) /]
[template public generatesMonovaluedFieldConditions(element: Element, varname: String, field: Element, mappedFieldName: String, mappedFieldMetaclass: String) ? (field = null)]
[varname /].[mappedFieldName /] = null
[/template]

[template public generatesMonovaluedFieldConditions(element: Element, varname: String, field: Element, mappedFieldName: String, mappedFieldMetaclass: String) ? (field <> null and getElementsVisited()->includes(field) and not field.isElementPartOfClosureOperation())]
let tmp: [mappedFieldMetaclass /] = [varname /].[mappedFieldName /] in (not tmp.oclIsUndefined()) and
let tmp: [mappedFieldMetaclass /] = [field.getOclReferenceExpression('tmp') /] in
tmp = [field.getUniqueOclName() /]
[/template]

[template public generatesMonovaluedFieldConditions(element: Element, varname: String, field: Element, mappedFieldName: String, mappedFieldMetaclass: String) ? (field <> null and (not getElementsVisited()->includes(field)) and not field.isElementPartOfClosureOperation())]
let [field.getUniqueOclName() /] : [mappedFieldMetaclass /] = [varname /].[mappedFieldName /] in (not [field.getUniqueOclName() /].oclIsUndefined()) and
let [field.getUniqueOclName() /] = [field.getOclReferenceExpression(field.getUniqueOclName()) /] in
[let fieldConditions: String = field.generatesFieldConditions(mappedFieldMetaclass)] 
[if fieldConditions.isNotEmpty()]
[fieldConditions.printStringWithIdentation() /][else]
true[/if][/let]
[/template]

[comment Gerar condicoes de atributo monovalorado (varias metaclasses mapeadas) /]
[template public generatesMonovaluedFieldConditions(element: Element, varname: String, field: Element, mappedFieldName: String, mappedFieldMetaclass: String, mappedElementMetaclasses: OrderedSet(String))  ? (field = null)]
[element.generatesLetIfObject(varname, mappedFieldName, mappedElementMetaclasses, 'tmp', mappedFieldMetaclass) /] tmp = null
[/template]

[template public generatesMonovaluedFieldConditions(element: Element, varname: String, field: Element, mappedFieldName: String, mappedFieldMetaclass: String, mappedElementMetaclasses: OrderedSet(String))  ? (field <> null and getElementsVisited()->includes(field) and not field.isElementPartOfClosureOperation())]
[element.generatesLetIfObject(varname, mappedFieldName, mappedElementMetaclasses, 'tmp', mappedFieldMetaclass) /] 
let tmp: [mappedFieldMetaclass /] = [field.getOclReferenceExpression('tmp') /] in
tmp = [field.getUniqueOclName() /] 
[/template]

[template public generatesMonovaluedFieldConditions(element: Element, varname: String, field: Element, mappedFieldName: String, mappedFieldMetaclass: String, mappedElementMetaclasses: OrderedSet(String)) ? (field <> null and not getElementsVisited()->includes(field) and not field.isElementPartOfClosureOperation())]
[let fieldConditions: String = field.generatesFieldConditions(mappedFieldMetaclass)]
[element.generatesLetIfObject(varname, mappedFieldName, mappedElementMetaclasses, field.getUniqueOclName(), mappedFieldMetaclass)/] (not [field.getUniqueOclName() /].oclIsUndefined()) and
let [field.getUniqueOclName() /]: [mappedFieldMetaclass /] = [field.getOclReferenceExpression(field.getUniqueOclName()) /] in [if fieldConditions.isNotEmpty()]
[fieldConditions.printStringWithIdentation() /][else]true[/if][/let]
[/template]

[comment Gerar condicoes de atributo monovalorado (com mapeamento de metaclasse e atributo) /]
[template public generatesMonovaluedFieldConditions(element: Element, varname: String, field: Element, mappedFieldMetaclass: String, map: OrderedSet(OrderedSet(String))) ? (field = null)]
[element.generatesLetIfObject(varname, map, 'tmp', mappedFieldMetaclass) /] tmp = null
[/template]

[template public generatesMonovaluedFieldConditions(element: Element, varname: String, field: Element, mappedFieldMetaclass: String, map: OrderedSet(OrderedSet(String))) ? (field <> null and getElementsVisited()->includes(field) and not field.isElementPartOfClosureOperation())]
[element.generatesLetIfObject(varname, map, 'tmp', mappedFieldMetaclass) /] 
let tmp: [mappedFieldMetaclass /] = [field.getOclReferenceExpression('tmp') /] in
tmp = [field.getUniqueOclName() /]
[/template]

[template public generatesMonovaluedFieldConditions(element: Element, varname: String, field: Element, mappedFieldMetaclass: String, map: OrderedSet(OrderedSet(String))) ? (field <> null and not getElementsVisited()->includes(field) and not field.isElementPartOfClosureOperation())]
[let fieldConditions: String = field.generatesFieldConditions(mappedFieldMetaclass)]
[element.generatesLetIfObject(varname, map, field.getUniqueOclName(), mappedFieldMetaclass) /] (not [field.getUniqueOclName() /].oclIsUndefined())
let [field.getUniqueOclName() /]: [mappedFieldMetaclass /] = [field.getOclReferenceExpression(field.getUniqueOclName()) /] in [if fieldConditions.isNotEmpty()]
[fieldConditions.printStringWithIdentation() /][else]true[/if][/let]
[/template]

[comment Gerar condicoes de atributo multivalorado com acesso direto /]
[template public generatesMultivaluedFieldConditions(element: Element, varname: String, fields: OrderedSet(Element), letOclName: String, mappedFieldName: String, mappedFieldMetaclass: String)]
[let fieldsConditions: String = element.generatesMultivaluedFieldConditions(letOclName, fields, mappedFieldMetaclass)]
[if fieldsConditions.isNotEmpty()]
let [letOclName /]: OrderedSet([mappedFieldMetaclass /]) = [varname /].[mappedFieldName /] in (not [letOclName /]->oclIsUndefined()) and
[fieldsConditions.printStringWithIdentation() /][/if][/let]
[/template]

[comment Gerar condicoes de atributo multivalorado com lista de possiveis metaclasses /]
[template public generatesMultivaluedFieldConditions(element: Element, varname: String, fields: OrderedSet(Element), mappedElementMetaclasses: OrderedSet(String), letOclName: String, mappedFieldName: String, mappedFieldMetaclass: String)]
[let fieldsConditions: String = element.generatesMultivaluedFieldConditions(letOclName, fields, mappedFieldMetaclass)]
[element.generatesLetIfObject(varname, mappedFieldName, mappedElementMetaclasses, letOclName, 'OrderedSet('.concat(mappedFieldMetaclass).concat(')')) /][if fieldsConditions.isNotEmpty()] and
[fieldsConditions.printStringWithIdentation() /][/if][/let]
[/template]

[template public generatesMultivaluedFieldConditions(element: Element,  letOclFieldName: String, fields: OrderedSet(Element), mappedFieldMetaclass: String)]
[let tmpFields: OrderedSet(Element) = fields->select(element: Element | not element.isElementPartOfClosureOperation())]
[for (field: Element | tmpFields) separator(' and ')]
  [field.generatesMultivaluedFieldCondition(letOclFieldName, mappedFieldMetaclass) /]
[/for][if element.oclIsKindOf(CodeElement) and element.oclAsType(CodeElement).exact][if tmpFields->size() > 0] and
[/if][letOclFieldName /]->size() = [tmpFields->size() /][/if][/let]
[/template]

[template public generatesMultivaluedFieldCondition(field: Element, letSetName: String, mappedFieldMetaclass: String) ? (getElementsVisited()->includes(field))]
[letSetName /]->exists(tmp |
  let tmp: [mappedFieldMetaclass /] = [field.getOclReferenceExpression('tmp') /] in
  tmp = [field.getUniqueOclName() /]
)
[/template]

[template public generatesMultivaluedFieldCondition(field: Element, letSetName: String, mappedFieldMetaclass: String) ? (not getElementsVisited()->includes(field))]
[letSetName /]->exists(tmp | [field.addElementExistsDeclaration() /]
let [field.getUniqueOclName() /]: [mappedFieldMetaclass /] = [field.getOclReferenceExpression('tmp') /] in
[let fieldCondition: String = field.generatesFieldConditions(mappedFieldMetaclass)]
[if fieldCondition.isNotEmpty()]
  [fieldCondition.printStringWithIdentation() /][else]
  true[/if][/let]
[/template]
