[comment encoding = UTF-8 /]
[module genericFieldConditionsGenerator('http://www.example.org/ccsl')]

[import org::ccsl::gen::ocl::dispatchers::generatesElementConditionsDispatcher /]
[import org::ccsl::gen::ocl::commom::uniqueNameGeneratorModule /]
[import org::ccsl::gen::ocl::commom::walkHelperModule /]
[import org::ccsl::gen::ocl::commom::getOclElementReferenceModule /] 
[import org::ccsl::gen::ocl::commom::stringUtils /]
[import org::ccsl::gen::ocl::commom::elementUtils /]


[template public getFieldName(field: Element)]
[if field = null]
nullTmp[elseif getElementsVisited()->includes(field)]
[field.getBaseName() /]Tmp[else]
[field.getUniqueOclName() /][/if]
[/template]

[comment generates get field expression /]
[template public generatesGetFieldExpression(element: Element, elementOclVarname: String, fieldOclVarname: String, mappedFieldPropertyName: String, mappedFieldMetaclass: String) post(trim())]
let [fieldOclVarname /]: [mappedFieldMetaclass /] = [elementOclVarname /].[mappedFieldPropertyName /] in
[/template]

[template public generatesGetFieldExpression(element: Element, elementOclVarname: String, fieldOclVarname: String, mappedFieldPropertyName: String, mappedFieldMetaclass: String, elementMetaclasses: OrderedSet(String)) post(trim())]
let [fieldOclVarname /]: [mappedFieldMetaclass /] = [for(metaclass: String | elementMetaclasses) separator('else ')]
if [elementOclVarname /].oclIsKindOf([metaclass /]) then
  [elementOclVarname /].oclAsType([metaclass /]).[mappedFieldPropertyName /]
[/for]
else
  null
[for (Sequence(Integer){1..elementMetaclasses->size()}) separator(' ')]endif[/for] in
[/template]

[template public generatesGetFieldExpression(element: Element, elementOclVarname: String, fieldOclVarname: String, mappedFieldMetaclass: String, map: OrderedSet(OrderedSet(String)))]
let [fieldOclVarname /]: [mappedFieldMetaclass /] = [for(entry: OrderedSet(String) | map) separator('else ')]
if [elementOclVarname /].oclIsKindOf([entry->at(1) /]) then
  [elementOclVarname /].oclAsType([entry->at(1) /]).[entry->at(2) /]
[/for]
else
  null
[for (Sequence(Integer){1..map->size()}) separator(' ')]endif[/for] in
[/template]

[template private generatesFieldConditionPrvt(element: Element, field: Element, fieldOclVarname: String, mappedFieldMetaclass: String) ? (field = null)]
[fieldOclVarname /] = null
[/template]

[template private generatesFieldConditionPrvt(element: Element, field: Element, fieldOclVarname: String,  mappedFieldMetaclass: String) ? (field <> null and getElementsVisited()->includes(field))]
[fieldOclVarname /] = [field.getUniqueOclName() /]
[/template]

[template private generatesFieldConditionPrvt(element: Element, field: Element, fieldOclVarname: String,  mappedFieldMetaclass: String) ? (field <> null and not getElementsVisited()->includes(field))]
[fieldOclVarname /] <> null and
[if mappedFieldMetaclass = 'ASTNode' or mappedFieldMetaclass = 'OclAny']
[field.generatesConditions(field.getUniqueOclName(), true) /][else]
[field.generatesConditions(field.getUniqueOclName(), false, mappedFieldMetaclass) /][/if]
[/template]

[template public generatesFieldCondition(element: Element, field: Element, fieldOclVarname: String, mappedFieldMetaclass: String) ? (not element.isClosureRelation(field))]
[let fieldRef: String = if field <> null then
    field.getOclReferenceExpression(fieldOclVarname, mappedFieldMetaclass)
  else
    ''
  endif
]
[if fieldRef.isNotEmpty()]
[fieldRef.printStringWithIdentation() /]
[/if][/let][element.generatesFieldConditionPrvt(field, fieldOclVarname, mappedFieldMetaclass) /]
[/template]

[comment generates get field expression for monovalued values /]
[template public generatesMonovaluedFieldConditions(element: Element, field: Element, elementOclVarname: String, mappedFieldPropertyName: String, mappedFieldMetaclass: String) ? (not element.isClosureRelation(field)) post(trim()) ]
[let fieldOclVarname: String = field.getFieldName()]
[element.generatesGetFieldExpression(elementOclVarname, fieldOclVarname, mappedFieldPropertyName, mappedFieldMetaclass) /]
[element.generatesFieldCondition(field, fieldOclVarname, mappedFieldMetaclass) /][/let]
[/template]

[template public generatesMonovaluedFieldConditions(element: Element, field: Element, elementOclVarname: String, mappedFieldPropertyName: String, mappedFieldMetaclass: String, elementMetaclasses: OrderedSet(String)) ? (not element.isClosureRelation(field)) post(trim())]
[let fieldOclVarname: String = field.getFieldName()]
[element.generatesGetFieldExpression(elementOclVarname, fieldOclVarname, mappedFieldPropertyName, mappedFieldMetaclass, elementMetaclasses) /]
[element.generatesFieldCondition(field, fieldOclVarname, mappedFieldMetaclass) /][/let]
[/template]

[template public generatesMonovaluedFieldConditions(element: Element, field: Element, elementOclVarname: String, mappedFieldMetaclass: String, map: OrderedSet(OrderedSet(String))) ? (not element.isClosureRelation(field)) post(trim())]
[let fieldOclVarname: String = field.getFieldName()]
[element.generatesGetFieldExpression(elementOclVarname, fieldOclVarname, mappedFieldMetaclass, map) /]
[element.generatesFieldCondition(field, fieldOclVarname, mappedFieldMetaclass) /][/let]
[/template]

[comment Gerar condicoes de atributo multivalorado com acesso direto /]
[template public generatesMultivaluedFieldConditions(element: Element, fields: OrderedSet(Element), elementOclVarname: String, fieldsOclVarname: String, mappedPropertyFieldName: String, mappedFieldMetaclass: String)]
[element.generatesGetFieldExpression(elementOclVarname, fieldsOclVarname, mappedPropertyFieldName, 'OrderedSet('.concat(mappedFieldMetaclass).concat(')')) /]
[element.generatesSetConditions(fieldsOclVarname, fields, mappedFieldMetaclass) /]
[/template]

[**
 * Generates conditions for a multivalue property of @element.
*/]
[template public generatesMultivaluedFieldConditions(element: Element, fields: OrderedSet(Element), elementOclVarname: String, fieldsOclVarname: String , mappedPropertyFieldName: String, mappedFieldMetaclass: String, elementMetaclasses: OrderedSet(String))]
[element.generatesGetFieldExpression(elementOclVarname, fieldsOclVarname, mappedPropertyFieldName, 'OrderedSet('.concat(mappedFieldMetaclass).concat(')'), elementMetaclasses) /]
[element.generatesSetConditions(fieldsOclVarname, fields, mappedFieldMetaclass) /]
[/template]

[template public generatesSetConditions(element: Element,  setOclName: String, fields: OrderedSet(Element), mappedFieldMetaclass: String)]
[let tmpFields: OrderedSet(Element) = fields->select(field: Element | not element.isClosureRelation(field))]
[for (field: Element | tmpFields) separator(' and ')]
  [setOclName /]->[field.generatesExistsDeclaration(mappedFieldMetaclass) /]
[/for][if element.oclIsKindOf(CodeElement) and element.oclAsType(CodeElement).exact][if tmpFields->size() > 0] and
[/if][setOclName /]->size() = [tmpFields->size() /][/if][/let]
[/template]

[template private generatesExistsDeclaration(field: Element, mappedFieldMetaclass: String) ? (getElementsVisited()->includes(field))]
[let fieldName: String = field.getFieldName()]
exists([fieldName /] |
  [field.generatesFieldCondition(field, fieldName, mappedFieldMetaclass) /]
)[/let]
[/template]

[template private generatesExistsDeclaration(field: Element, mappedFieldMetaclass: String) ? (not getElementsVisited()->includes(field))]
[let fieldName: String = field.getUniqueOclName()]
exists([fieldName /] | [field.addElementExistsDeclaration() /]
  [field.generatesFieldCondition(field, fieldName, mappedFieldMetaclass) /][/let]
[/template]
