let violations: Set(ASTNode) = InfixExpression.allInstances()->union(PrefixExpression.allInstances())->select(booleanExpression |
  --Context Conditions
  if booleanExpression.oclIsKindOf(InfixExpression) then
    let booleanInfixExpressionOperators: Set(InfixExpressionKind) = Set(InfixExpressionKind){
      InfixExpressionKind::LESS,
      InfixExpressionKind::GREATER,
      InfixExpressionKind::LESS_EQUALS,
      InfixExpressionKind::GREATER_EQUALS,
      InfixExpressionKind::EQUALS,
      InfixExpressionKind::NOT_EQUALS,
      InfixExpressionKind::CONDITIONAL_AND,
      InfixExpressionKind::CONDITIONAL_OR
    } in booleanInfixExpressionOperators->exists(op | op = booleanExpression.oclAsType(InfixExpression).operator)
  else if booleanExpression.oclIsKindOf(PrefixExpression) then
    booleanExpression.oclAsType(PrefixExpression).operator = PrefixExpressionKind::NOT
  else
    false
  endif endif  and 
  --Filters Conditions
  (
    -- Composite Filter (OR)
    (
      -- Template Filter
      let templateAndBooleanExpression: ASTNode = booleanExpression in
      templateAndBooleanExpression.oclIsKindOf(InfixExpression) and
      templateAndBooleanExpression.oclAsType(InfixExpression).operator = InfixExpressionKind::CONDITIONAL_AND and
      let ifStmt1 : OclAny = templateAndBooleanExpression.oclAsType(InfixExpression).oclContainer() in ifStmt1 <> null and
      ifStmt1.oclIsKindOf(IfStatement) and
      let stmtTmp: ASTNode = ifStmt1.oclAsType(IfStatement).expression->asOrderedSet()->closure(n | if n.oclIsKindOf(ParenthesizedExpression) then n.oclAsType(ParenthesizedExpression).expression else n endif)->last() in
      stmtTmp = templateAndBooleanExpression
      -- End Template Filter
    ) or 
    (
      --Closure Filter
      let closureTemplateAndBooleanExpression: ASTNode = booleanExpression in
      let closureSet: OrderedSet(ASTNode) = closureTemplateAndBooleanExpression->closure(n: ASTNode |
        let container: OclAny = n.oclContainer() in
        if container <> null and container.oclIsKindOf(InfixExpression) and
          container.oclAsType(InfixExpression).extendedOperands
            ->append(container.oclAsType(InfixExpression).leftOperand)
            ->append(container.oclAsType(InfixExpression).rightOperand)
            ->exists(x | x = n) then
          container
        else if container.oclIsKindOf(PrefixExpression) and container.oclAsType(PrefixExpression).operand = n then
          container
        else if container.oclIsKindOf(ParenthesizedExpression) then
          container
        else if n.oclIsKindOf(ParenthesizedExpression) then
          n.oclAsType(ParenthesizedExpression)
        else
          null
        endif endif endif endif
      )->excluding(closureTemplateAndBooleanExpression) in
      closureSet->exists(anyInfixExpression: ASTNode |
        if anyInfixExpression.oclIsKindOf(InfixExpression) then
          let booleanInfixExpressionOperators: Set(InfixExpressionKind) = Set(InfixExpressionKind){
            InfixExpressionKind::LESS,
            InfixExpressionKind::GREATER,
            InfixExpressionKind::LESS_EQUALS,
            InfixExpressionKind::GREATER_EQUALS,
            InfixExpressionKind::EQUALS,
            InfixExpressionKind::NOT_EQUALS,
            InfixExpressionKind::CONDITIONAL_AND,
            InfixExpressionKind::CONDITIONAL_OR
          } in booleanInfixExpressionOperators->exists(op | op = anyInfixExpression.oclAsType(InfixExpression).operator)
        else if anyInfixExpression.oclIsKindOf(PrefixExpression) then
          anyInfixExpression.oclAsType(PrefixExpression).operator = PrefixExpressionKind::NOT
        else
          false
        endif endif and
        let ifStmt2 : OclAny = anyInfixExpression.oclContainer() in ifStmt2 <> null and
        ifStmt2.oclIsKindOf(IfStatement) and
        let stmtTmp: ASTNode = ifStmt2.oclAsType(IfStatement).expression->asOrderedSet()->closure(n | if n.oclIsKindOf(ParenthesizedExpression) then n.oclAsType(ParenthesizedExpression).expression else n endif)->last() in
        stmtTmp = anyInfixExpression and
      --Context Conditions
      closureTemplateAndBooleanExpression.oclIsKindOf(InfixExpression) and
      closureTemplateAndBooleanExpression.oclAsType(InfixExpression).operator = InfixExpressionKind::CONDITIONAL_AND
      )
    )
    -- End Composite Filter (OR)
  )
)
->reject(node: ASTNode | node.originalCompilationUnit.oclIsUndefined())
->reject(node: ASTNode | node->closure(oclContainer())->exists(oclIsKindOf(Javadoc))) in
violations->asSequence()->collect(node: ASTNode | 
	let container: NamedElement = node->asOrderedSet()->closure(x |
        if x.oclIsKindOf(AbstractMethodDeclaration) or x.oclIsKindOf(AbstractTypeDeclaration) then
		  x
		else
		  x.oclContainer()
	    endif
	)->last() in if (not container.oclIsUndefined()) and (not container.originalCompilationUnit.oclIsUndefined()) then
      'Violation Found at '.concat(container.originalCompilationUnit.originalFilePath).concat(' on ').concat(container.name)
    else
      ''
    endif
)->asSequence()->select(violation | violation.size() > 0)
->append('#violations: '.concat(violations->size().toString()))
