let violations: Set(ASTNode) = VariableDeclarationFragment.allInstances()->select(varWithLiteralInitialization |
  --AtomicRule Context Conditions
  (not varWithLiteralInitialization.oclIsKindOf(UnresolvedItem)) and
  let lit: ASTNode = if not varWithLiteralInitialization.variablesContainer.fragments->oclIsUndefined() then
    varWithLiteralInitialization.variablesContainer.fragments->asOrderedSet()->last().initializer
  else
    null
  endif in
  let lit: ASTNode = if lit <> null then
    lit->asOrderedSet()->closure(v: ASTNode | 
      if v.oclIsKindOf(ParenthesizedExpression) then 
        v.oclAsType(ParenthesizedExpression).expression 
      else 
        v 
      endif
    )->last()
  else
    null
  endif in
  lit <> null and
    (lit.oclIsKindOf(StringLiteral) or lit.oclIsKindOf(CharacterLiteral) or lit.oclIsKindOf(NumberLiteral) or lit.oclIsKindOf(BooleanLiteral) or lit.oclIsKindOf(NullLiteral))
)
->reject(node: ASTNode | node.originalCompilationUnit.oclIsUndefined())
->reject(node: ASTNode | node->closure(oclContainer())->exists(oclIsKindOf(Javadoc))) in
violations->asSequence()->collect(node: ASTNode | 
	let container: NamedElement = node->asOrderedSet()->closure(x |
        if x.oclIsKindOf(AbstractMethodDeclaration) or x.oclIsKindOf(AbstractTypeDeclaration) then
		  x
		else
		  x.oclContainer()
	    endif
	)->last() in if (not container.oclIsUndefined()) and (not container.originalCompilationUnit.oclIsUndefined()) then
      'Violation Found at '.concat(container.originalCompilationUnit.originalFilePath).concat(' on ').concat(container.name)
    else
      ''
    endif
)->asSequence()->select(violation | violation.size() > 0)
->append('#violations: '.concat(violations->size().toString()))
