/*
 * generated by Xtext 2.18.0.M3
 */
package org.ccsl.xtext.serializer;

import ccsl.AtomicRule;
import ccsl.CompositeRule;
import ccsl.ccslPackage;
import ccsl.context.Context;
import ccsl.context.ContextPackage;
import ccsl.elements.CodeElement;
import ccsl.elements.Element;
import ccsl.elements.ElementsPackage;
import ccsl.elements.Property;
import ccsl.elements.datatype.ArrayType;
import ccsl.elements.datatype.BooleanPrimitiveType;
import ccsl.elements.datatype.DataType;
import ccsl.elements.datatype.DatatypePackage;
import ccsl.elements.datatype.GenericType;
import ccsl.elements.datatype.IntPrimitiveType;
import ccsl.elements.datatype.ObjectType;
import ccsl.elements.datatype.ParameterizedType;
import ccsl.elements.datatype.PrimitiveType;
import ccsl.elements.datatype.ShortPrimitiveType;
import ccsl.elements.datatype.StringPrimitiveType;
import ccsl.elements.namedElements.ComplexType;
import ccsl.elements.namedElements.Constructor;
import ccsl.elements.namedElements.Method;
import ccsl.elements.namedElements.NamedElement;
import ccsl.elements.namedElements.NamedElementsPackage;
import ccsl.elements.namedElements.Variable;
import ccsl.elements.namedElements.VariableVector;
import ccsl.elements.statements.Access;
import ccsl.elements.statements.ArrayCreation;
import ccsl.elements.statements.Block;
import ccsl.elements.statements.ControlFlow;
import ccsl.elements.statements.DataTypeAccess;
import ccsl.elements.statements.InstanceCreation;
import ccsl.elements.statements.MethodInvocation;
import ccsl.elements.statements.NamedElementAccess;
import ccsl.elements.statements.Statement;
import ccsl.elements.statements.StatementsPackage;
import ccsl.elements.statements.SuperMethodInvocation;
import ccsl.elements.statements.SynchronizedBlock;
import ccsl.elements.statements.VarAssignment;
import ccsl.elements.statements.VarDeclaration;
import ccsl.elements.statements.VariableAccess;
import ccsl.elements.statements.controlFlow.ControlFlowPackage;
import ccsl.elements.statements.controlFlow.SwitchCaseBlock;
import ccsl.elements.statements.expressions.ArithmeticExpression;
import ccsl.elements.statements.expressions.Assignment;
import ccsl.elements.statements.expressions.BooleanExpression;
import ccsl.elements.statements.expressions.ExpressionsPackage;
import ccsl.elements.statements.expressions.InfixExpression;
import ccsl.elements.statements.expressions.OperatorExpression;
import ccsl.elements.statements.expressions.StringConcatenation;
import ccsl.filters.ChildComplexTypeFilter;
import ccsl.filters.CompositeFilter;
import ccsl.filters.DefinesMethodFilter;
import ccsl.filters.EqualsNamedElementWithLiterals;
import ccsl.filters.FiltersPackage;
import ccsl.filters.ImplicityContainerFilter;
import ccsl.filters.ImplicityOperandFilter;
import ccsl.filters.IsKindOfFilter;
import ccsl.filters.IsTypeOfFilter;
import ccsl.filters.PropertyFilter;
import ccsl.filters.RegexLiteralValueFilter;
import ccsl.filters.RegexMatch;
import ccsl.filters.SameNameFilter;
import ccsl.filters.SuperMethodClosureFilter;
import ccsl.filters.SwitchCaseStatementCount;
import ccsl.filters.TemplateFilter;
import ccsl.filters.TypedStatementFilter;
import com.google.inject.Inject;
import java.util.Set;
import org.ccsl.xtext.services.CcslGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CcslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CcslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ccslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ccslPackage.ATOMIC_RULE:
				sequence_AtomicRule(context, (AtomicRule) semanticObject); 
				return; 
			case ccslPackage.COMPOSITE_RULE:
				sequence_CompositeRule(context, (CompositeRule) semanticObject); 
				return; 
			}
		else if (epackage == ContextPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ContextPackage.CONTEXT:
				sequence_Context(context, (Context) semanticObject); 
				return; 
			}
		else if (epackage == ControlFlowPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ControlFlowPackage.SWITCH_CASE_BLOCK:
				sequence_SwitchCaseBlock(context, (SwitchCaseBlock) semanticObject); 
				return; 
			}
		else if (epackage == DatatypePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DatatypePackage.ARRAY_TYPE:
				sequence_ArrayType(context, (ArrayType) semanticObject); 
				return; 
			case DatatypePackage.BOOLEAN_PRIMITIVE_TYPE:
				sequence_BooleanPrimitiveType(context, (BooleanPrimitiveType) semanticObject); 
				return; 
			case DatatypePackage.DATA_TYPE:
				sequence_DataType_Impl(context, (DataType) semanticObject); 
				return; 
			case DatatypePackage.GENERIC_TYPE:
				sequence_GenericType(context, (GenericType) semanticObject); 
				return; 
			case DatatypePackage.INT_PRIMITIVE_TYPE:
				sequence_IntPrimitiveType(context, (IntPrimitiveType) semanticObject); 
				return; 
			case DatatypePackage.OBJECT_TYPE:
				sequence_ObjectType_Impl(context, (ObjectType) semanticObject); 
				return; 
			case DatatypePackage.PARAMETERIZED_TYPE:
				sequence_ParameterizedType(context, (ParameterizedType) semanticObject); 
				return; 
			case DatatypePackage.PRIMITIVE_TYPE:
				sequence_PrimitiveType_Impl(context, (PrimitiveType) semanticObject); 
				return; 
			case DatatypePackage.SHORT_PRIMITIVE_TYPE:
				sequence_ShortPrimitiveType(context, (ShortPrimitiveType) semanticObject); 
				return; 
			case DatatypePackage.STRING_PRIMITIVE_TYPE:
				sequence_StringPrimitiveType(context, (StringPrimitiveType) semanticObject); 
				return; 
			}
		else if (epackage == ElementsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ElementsPackage.CODE_ELEMENT:
				sequence_CodeElement(context, (CodeElement) semanticObject); 
				return; 
			case ElementsPackage.ELEMENT:
				sequence_Element_Impl(context, (Element) semanticObject); 
				return; 
			case ElementsPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			}
		else if (epackage == ExpressionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionsPackage.ARITHMETIC_EXPRESSION:
				sequence_ArithmeticExpression(context, (ArithmeticExpression) semanticObject); 
				return; 
			case ExpressionsPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case ExpressionsPackage.BOOLEAN_EXPRESSION:
				sequence_BooleanExpression(context, (BooleanExpression) semanticObject); 
				return; 
			case ExpressionsPackage.INFIX_EXPRESSION:
				sequence_InfixExpression(context, (InfixExpression) semanticObject); 
				return; 
			case ExpressionsPackage.OPERATOR_EXPRESSION:
				sequence_OperatorExpression_Impl(context, (OperatorExpression) semanticObject); 
				return; 
			case ExpressionsPackage.STRING_CONCATENATION:
				sequence_StringConcatenation(context, (StringConcatenation) semanticObject); 
				return; 
			}
		else if (epackage == FiltersPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FiltersPackage.CHILD_COMPLEX_TYPE_FILTER:
				sequence_ChildComplexTypeFilter(context, (ChildComplexTypeFilter) semanticObject); 
				return; 
			case FiltersPackage.COMPOSITE_FILTER:
				sequence_CompositeFilter(context, (CompositeFilter) semanticObject); 
				return; 
			case FiltersPackage.DEFINES_METHOD_FILTER:
				sequence_DefinesMethodFilter(context, (DefinesMethodFilter) semanticObject); 
				return; 
			case FiltersPackage.EQUALS_NAMED_ELEMENT_WITH_LITERALS:
				sequence_EqualsNamedElementWithLiterals(context, (EqualsNamedElementWithLiterals) semanticObject); 
				return; 
			case FiltersPackage.IMPLICITY_CONTAINER_FILTER:
				sequence_ImplicityContainerFilter(context, (ImplicityContainerFilter) semanticObject); 
				return; 
			case FiltersPackage.IMPLICITY_OPERAND_FILTER:
				sequence_ImplicityOperandFilter(context, (ImplicityOperandFilter) semanticObject); 
				return; 
			case FiltersPackage.IS_KIND_OF_FILTER:
				sequence_IsKindOfFilter(context, (IsKindOfFilter) semanticObject); 
				return; 
			case FiltersPackage.IS_TYPE_OF_FILTER:
				sequence_IsTypeOfFilter(context, (IsTypeOfFilter) semanticObject); 
				return; 
			case FiltersPackage.PROPERTY_FILTER:
				sequence_PropertyFilter(context, (PropertyFilter) semanticObject); 
				return; 
			case FiltersPackage.REGEX_LITERAL_VALUE_FILTER:
				sequence_RegexLiteralValueFilter(context, (RegexLiteralValueFilter) semanticObject); 
				return; 
			case FiltersPackage.REGEX_MATCH:
				sequence_RegexMatch(context, (RegexMatch) semanticObject); 
				return; 
			case FiltersPackage.SAME_NAME_FILTER:
				sequence_SameNameFilter(context, (SameNameFilter) semanticObject); 
				return; 
			case FiltersPackage.SUPER_METHOD_CLOSURE_FILTER:
				sequence_SuperMethodClosureFilter(context, (SuperMethodClosureFilter) semanticObject); 
				return; 
			case FiltersPackage.SWITCH_CASE_STATEMENT_COUNT:
				sequence_SwitchCaseStatementCount(context, (SwitchCaseStatementCount) semanticObject); 
				return; 
			case FiltersPackage.TEMPLATE_FILTER:
				sequence_TemplateFilter_Impl(context, (TemplateFilter) semanticObject); 
				return; 
			case FiltersPackage.TYPED_STATEMENT_FILTER:
				sequence_TypedStatementFilter(context, (TypedStatementFilter) semanticObject); 
				return; 
			}
		else if (epackage == NamedElementsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case NamedElementsPackage.COMPLEX_TYPE:
				sequence_ComplexType(context, (ComplexType) semanticObject); 
				return; 
			case NamedElementsPackage.CONSTRUCTOR:
				sequence_Constructor(context, (Constructor) semanticObject); 
				return; 
			case NamedElementsPackage.METHOD:
				sequence_Method_Impl(context, (Method) semanticObject); 
				return; 
			case NamedElementsPackage.NAMED_ELEMENT:
				sequence_NamedElement_Impl(context, (NamedElement) semanticObject); 
				return; 
			case NamedElementsPackage.PACKAGE:
				sequence_Package(context, (ccsl.elements.namedElements.Package) semanticObject); 
				return; 
			case NamedElementsPackage.VARIABLE:
				sequence_Variable_Impl(context, (Variable) semanticObject); 
				return; 
			case NamedElementsPackage.VARIABLE_VECTOR:
				sequence_VariableVector(context, (VariableVector) semanticObject); 
				return; 
			}
		else if (epackage == StatementsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StatementsPackage.ACCESS:
				sequence_Access_Impl(context, (Access) semanticObject); 
				return; 
			case StatementsPackage.ARRAY_CREATION:
				sequence_ArrayCreation(context, (ArrayCreation) semanticObject); 
				return; 
			case StatementsPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case StatementsPackage.CONTROL_FLOW:
				sequence_ControlFlow(context, (ControlFlow) semanticObject); 
				return; 
			case StatementsPackage.DATA_TYPE_ACCESS:
				sequence_DataTypeAccess(context, (DataTypeAccess) semanticObject); 
				return; 
			case StatementsPackage.INSTANCE_CREATION:
				sequence_InstanceCreation(context, (InstanceCreation) semanticObject); 
				return; 
			case StatementsPackage.METHOD_INVOCATION:
				sequence_MethodInvocation_Impl(context, (MethodInvocation) semanticObject); 
				return; 
			case StatementsPackage.NAMED_ELEMENT_ACCESS:
				sequence_NamedElementAccess(context, (NamedElementAccess) semanticObject); 
				return; 
			case StatementsPackage.STATEMENT:
				sequence_Statement_Impl(context, (Statement) semanticObject); 
				return; 
			case StatementsPackage.SUPER_METHOD_INVOCATION:
				sequence_SuperMethodInvocation(context, (SuperMethodInvocation) semanticObject); 
				return; 
			case StatementsPackage.SYNCHRONIZED_BLOCK:
				sequence_SynchronizedBlock(context, (SynchronizedBlock) semanticObject); 
				return; 
			case StatementsPackage.VAR_ASSIGNMENT:
				sequence_VarAssignment(context, (VarAssignment) semanticObject); 
				return; 
			case StatementsPackage.VAR_DECLARATION:
				sequence_VarDeclaration(context, (VarDeclaration) semanticObject); 
				return; 
			case StatementsPackage.VARIABLE_ACCESS:
				sequence_VariableAccess(context, (VariableAccess) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Statement returns Access
	 *     Access_Impl returns Access
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? elementAccessed=[Element|EString]? (properties+=Property properties+=Property*)? from=Statement?)
	 */
	protected void sequence_Access_Impl(ISerializationContext context, Access semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperatorExpression returns ArithmeticExpression
	 *     ArithmeticExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0 
	 *         exact=Boolean? 
	 *         arithmeticOperator=ArithmeticOperator? 
	 *         (properties+=Property properties+=Property*)? 
	 *         (operands+=Statement operands+=Statement*)?
	 *     )
	 */
	protected void sequence_ArithmeticExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ArrayCreation
	 *     ArrayCreation returns ArrayCreation
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? type=[ObjectType|EString]? (properties+=Property properties+=Property*)?)
	 */
	protected void sequence_ArrayCreation(ISerializationContext context, ArrayCreation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns ArrayType
	 *     ObjectType returns ArrayType
	 *     ArrayType returns ArrayType
	 *
	 * Constraint:
	 *     (uniqueName=String0 dimensions=Int0? type=[DataType|EString]?)
	 */
	protected void sequence_ArrayType(ISerializationContext context, ArrayType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperatorExpression returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? (properties+=Property properties+=Property*)? (operands+=Statement operands+=Statement*)? target=Statement?)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns AtomicRule
	 *     AtomicRule returns AtomicRule
	 *
	 * Constraint:
	 *     (negated=Boolean? context=Context subject=[Element|ID])
	 */
	protected void sequence_AtomicRule(ISerializationContext context, AtomicRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Block
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? (properties+=Property properties+=Property*)? (statements+=Statement statements+=Statement*)?)
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperatorExpression returns BooleanExpression
	 *     BooleanExpression returns BooleanExpression
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0 
	 *         exact=Boolean? 
	 *         booleanOperator=BooleanOperator? 
	 *         (properties+=Property properties+=Property*)? 
	 *         (operands+=Statement operands+=Statement*)?
	 *     )
	 */
	protected void sequence_BooleanExpression(ISerializationContext context, BooleanExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns BooleanPrimitiveType
	 *     BooleanPrimitiveType returns BooleanPrimitiveType
	 *
	 * Constraint:
	 *     uniqueName=String0
	 */
	protected void sequence_BooleanPrimitiveType(ISerializationContext context, BooleanPrimitiveType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanPrimitiveTypeAccess().getUniqueNameString0ParserRuleCall_2_0(), semanticObject.getUniqueName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns ChildComplexTypeFilter
	 *     ChildComplexTypeFilter returns ChildComplexTypeFilter
	 *
	 * Constraint:
	 *     (
	 *         negated=Boolean? 
	 *         targets+=[Element|EString] 
	 *         targets+=[Element|EString]* 
	 *         superComplexType=[ComplexType|EString] 
	 *         childComplexType=[ComplexType|EString] 
	 *         context=Context
	 *     )
	 */
	protected void sequence_ChildComplexTypeFilter(ISerializationContext context, ChildComplexTypeFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns CodeElement
	 *     CodeElement returns CodeElement
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? (properties+=Property properties+=Property*)?)
	 */
	protected void sequence_CodeElement(ISerializationContext context, CodeElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns ComplexType
	 *     ComplexType returns ComplexType
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0 
	 *         exact=Boolean? 
	 *         name=String0? 
	 *         (superTypes+=[ComplexType|EString] superTypes+=[ComplexType|EString]*)? 
	 *         (properties+=Property properties+=Property*)? 
	 *         (statements+=Statement statements+=Statement*)? 
	 *         (fields+=Variable fields+=Variable*)? 
	 *         (methods+=Method methods+=Method*)?
	 *     )
	 */
	protected void sequence_ComplexType(ISerializationContext context, ComplexType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns CompositeFilter
	 *     CompositeFilter returns CompositeFilter
	 *
	 * Constraint:
	 *     (negated=Boolean? operator=LogicOperator? filters+=Filter filters+=Filter*)
	 */
	protected void sequence_CompositeFilter(ISerializationContext context, CompositeFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns CompositeRule
	 *     CompositeRule returns CompositeRule
	 *
	 * Constraint:
	 *     (negated=Boolean? operator=LogicOperator? rules+=Rule rules+=Rule*)
	 */
	protected void sequence_CompositeRule(ISerializationContext context, CompositeRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Method returns Constructor
	 *     NamedElement returns Constructor
	 *     Constructor returns Constructor
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0 
	 *         exact=Boolean? 
	 *         name=String0? 
	 *         returnType=[DataType|EString]? 
	 *         (properties+=Property properties+=Property*)? 
	 *         (statements+=Statement statements+=Statement*)? 
	 *         (params+=Variable params+=Variable*)?
	 *     )
	 */
	protected void sequence_Constructor(ISerializationContext context, Constructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns Context
	 *
	 * Constraint:
	 *     ((contextElements+=Element contextElements+=Element*)? (filters+=Filter filters+=Filter*)?)
	 */
	protected void sequence_Context(ISerializationContext context, Context semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ControlFlow
	 *     ControlFlow returns ControlFlow
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? (properties+=Property properties+=Property*)? condition=Statement?)
	 */
	protected void sequence_ControlFlow(ISerializationContext context, ControlFlow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DataTypeAccess
	 *     DataTypeAccess returns DataTypeAccess
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? elementAccessed=[Element|EString]? (properties+=Property properties+=Property*)? from=Statement?)
	 */
	protected void sequence_DataTypeAccess(ISerializationContext context, DataTypeAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns DataType
	 *     DataType_Impl returns DataType
	 *
	 * Constraint:
	 *     uniqueName=String0
	 */
	protected void sequence_DataType_Impl(ISerializationContext context, DataType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataType_ImplAccess().getUniqueNameString0ParserRuleCall_2_0(), semanticObject.getUniqueName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns DefinesMethodFilter
	 *     DefinesMethodFilter returns DefinesMethodFilter
	 *
	 * Constraint:
	 *     (negated=Boolean? targets+=[Element|EString] targets+=[Element|EString]* methods+=Method methods+=Method*)
	 */
	protected void sequence_DefinesMethodFilter(ISerializationContext context, DefinesMethodFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Element
	 *     Element_Impl returns Element
	 *
	 * Constraint:
	 *     uniqueName=ID
	 */
	protected void sequence_Element_Impl(ISerializationContext context, Element semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElement_ImplAccess().getUniqueNameIDTerminalRuleCall_3_0(), semanticObject.getUniqueName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns EqualsNamedElementWithLiterals
	 *     EqualsNamedElementWithLiterals returns EqualsNamedElementWithLiterals
	 *
	 * Constraint:
	 *     (negated=Boolean? names=String0? ignoreCase=Boolean? targets+=[Element|EString] targets+=[Element|EString]*)
	 */
	protected void sequence_EqualsNamedElementWithLiterals(ISerializationContext context, EqualsNamedElementWithLiterals semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns GenericType
	 *     ObjectType returns GenericType
	 *     GenericType returns GenericType
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0 
	 *         exact=Boolean? 
	 *         name=String0? 
	 *         (superTypes+=[ComplexType|EString] superTypes+=[ComplexType|EString]*)? 
	 *         (properties+=Property properties+=Property*)? 
	 *         (statements+=Statement statements+=Statement*)? 
	 *         (fields+=Variable fields+=Variable*)? 
	 *         (methods+=Method methods+=Method*)?
	 *     )
	 */
	protected void sequence_GenericType(ISerializationContext context, GenericType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns ImplicityContainerFilter
	 *     ImplicityContainerFilter returns ImplicityContainerFilter
	 *
	 * Constraint:
	 *     (
	 *         negated=Boolean? 
	 *         targets+=[Element|EString] 
	 *         targets+=[Element|EString]* 
	 *         implicityContainer=[Element|EString] 
	 *         implicityField=[Element|EString] 
	 *         context=Context
	 *     )
	 */
	protected void sequence_ImplicityContainerFilter(ISerializationContext context, ImplicityContainerFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns ImplicityOperandFilter
	 *     ImplicityOperandFilter returns ImplicityOperandFilter
	 *
	 * Constraint:
	 *     (
	 *         negated=Boolean? 
	 *         targets+=[Element|EString] 
	 *         targets+=[Element|EString]* 
	 *         targetTemplate=[Element|EString] 
	 *         implicityOperand=[Element|EString] 
	 *         operatorExpression=[OperatorExpression|EString] 
	 *         context=Context
	 *     )
	 */
	protected void sequence_ImplicityOperandFilter(ISerializationContext context, ImplicityOperandFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperatorExpression returns InfixExpression
	 *     InfixExpression returns InfixExpression
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? (properties+=Property properties+=Property*)? (operands+=Statement operands+=Statement*)?)
	 */
	protected void sequence_InfixExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns InstanceCreation
	 *     InstanceCreation returns InstanceCreation
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? type=[ObjectType|EString]? (properties+=Property properties+=Property*)?)
	 */
	protected void sequence_InstanceCreation(ISerializationContext context, InstanceCreation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns IntPrimitiveType
	 *     IntPrimitiveType returns IntPrimitiveType
	 *
	 * Constraint:
	 *     uniqueName=String0
	 */
	protected void sequence_IntPrimitiveType(ISerializationContext context, IntPrimitiveType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntPrimitiveTypeAccess().getUniqueNameString0ParserRuleCall_2_0(), semanticObject.getUniqueName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns IsKindOfFilter
	 *     IsKindOfFilter returns IsKindOfFilter
	 *
	 * Constraint:
	 *     (negated=Boolean? targets+=[Element|EString] targets+=[Element|EString]* type=[DataType|EString] context=Context)
	 */
	protected void sequence_IsKindOfFilter(ISerializationContext context, IsKindOfFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns IsTypeOfFilter
	 *     IsTypeOfFilter returns IsTypeOfFilter
	 *
	 * Constraint:
	 *     (negated=Boolean? targets+=[Element|EString] targets+=[Element|EString]* type=[DataType|EString] context=Context)
	 */
	protected void sequence_IsTypeOfFilter(ISerializationContext context, IsTypeOfFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MethodInvocation
	 *     MethodInvocation_Impl returns MethodInvocation
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0 
	 *         exact=Boolean? 
	 *         elementAccessed=[Element|EString]? 
	 *         (properties+=Property properties+=Property*)? 
	 *         from=Statement? 
	 *         (args+=Statement args+=Statement*)?
	 *     )
	 */
	protected void sequence_MethodInvocation_Impl(ISerializationContext context, MethodInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Method returns Method
	 *     NamedElement returns Method
	 *     Method_Impl returns Method
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0 
	 *         exact=Boolean? 
	 *         name=String0? 
	 *         returnType=[DataType|EString]? 
	 *         (properties+=Property properties+=Property*)? 
	 *         (statements+=Statement statements+=Statement*)? 
	 *         (params+=Variable params+=Variable*)?
	 *     )
	 */
	protected void sequence_Method_Impl(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns NamedElementAccess
	 *     NamedElementAccess returns NamedElementAccess
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? from=[Statement|EString]? (properties+=Property properties+=Property*)?)
	 */
	protected void sequence_NamedElementAccess(ISerializationContext context, NamedElementAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns NamedElement
	 *     NamedElement_Impl returns NamedElement
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? name=String0? (properties+=Property properties+=Property*)?)
	 */
	protected void sequence_NamedElement_Impl(ISerializationContext context, NamedElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns ObjectType
	 *     ObjectType returns ObjectType
	 *     ObjectType_Impl returns ObjectType
	 *
	 * Constraint:
	 *     uniqueName=String0
	 */
	protected void sequence_ObjectType_Impl(ISerializationContext context, ObjectType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectType_ImplAccess().getUniqueNameString0ParserRuleCall_2_0(), semanticObject.getUniqueName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OperatorExpression returns OperatorExpression
	 *     OperatorExpression_Impl returns OperatorExpression
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? (properties+=Property properties+=Property*)? (operands+=Statement operands+=Statement*)?)
	 */
	protected void sequence_OperatorExpression_Impl(ISerializationContext context, OperatorExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Package
	 *     Package returns Package
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0 
	 *         exact=Boolean? 
	 *         name=String0? 
	 *         (properties+=Property properties+=Property*)? 
	 *         (groupedClasses+=ComplexType groupedClasses+=ComplexType*)?
	 *     )
	 */
	protected void sequence_Package(ISerializationContext context, ccsl.elements.namedElements.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns ParameterizedType
	 *     ObjectType returns ParameterizedType
	 *     ParameterizedType returns ParameterizedType
	 *
	 * Constraint:
	 *     (uniqueName=String0 (typeParameters+=[ObjectType|EString] typeParameters+=[ObjectType|EString]*)? type=[ComplexType|EString]?)
	 */
	protected void sequence_ParameterizedType(ISerializationContext context, ParameterizedType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns PrimitiveType
	 *     PrimitiveType_Impl returns PrimitiveType
	 *
	 * Constraint:
	 *     uniqueName=String0
	 */
	protected void sequence_PrimitiveType_Impl(ISerializationContext context, PrimitiveType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveType_ImplAccess().getUniqueNameString0ParserRuleCall_2_0(), semanticObject.getUniqueName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns PropertyFilter
	 *     PropertyFilter returns PropertyFilter
	 *
	 * Constraint:
	 *     (negated=Boolean? targets+=[Element|EString] targets+=[Element|EString]* properties+=Property properties+=Property*)
	 */
	protected void sequence_PropertyFilter(ISerializationContext context, PropertyFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (name=String0? value=String0?)
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns RegexLiteralValueFilter
	 *     RegexLiteralValueFilter returns RegexLiteralValueFilter
	 *
	 * Constraint:
	 *     (negated=Boolean? regex=String0? targets+=[Element|EString] targets+=[Element|EString]*)
	 */
	protected void sequence_RegexLiteralValueFilter(ISerializationContext context, RegexLiteralValueFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns RegexMatch
	 *     RegexMatch returns RegexMatch
	 *
	 * Constraint:
	 *     (negated=Boolean? regex=String0? targets+=[Element|EString] targets+=[Element|EString]*)
	 */
	protected void sequence_RegexMatch(ISerializationContext context, RegexMatch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns SameNameFilter
	 *     SameNameFilter returns SameNameFilter
	 *
	 * Constraint:
	 *     (
	 *         negated=Boolean? 
	 *         ignoreCase=Boolean? 
	 *         targets+=[Element|EString] 
	 *         targets+=[Element|EString]* 
	 *         (elements+=[NamedElement|EString] elements+=[NamedElement|EString]*)?
	 *     )
	 */
	protected void sequence_SameNameFilter(ISerializationContext context, SameNameFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns ShortPrimitiveType
	 *     ShortPrimitiveType returns ShortPrimitiveType
	 *
	 * Constraint:
	 *     uniqueName=String0
	 */
	protected void sequence_ShortPrimitiveType(ISerializationContext context, ShortPrimitiveType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShortPrimitiveTypeAccess().getUniqueNameString0ParserRuleCall_2_0(), semanticObject.getUniqueName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *     Statement_Impl returns Statement
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? (properties+=Property properties+=Property*)?)
	 */
	protected void sequence_Statement_Impl(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperatorExpression returns StringConcatenation
	 *     StringConcatenation returns StringConcatenation
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? (properties+=Property properties+=Property*)? (operands+=Statement operands+=Statement*)?)
	 */
	protected void sequence_StringConcatenation(ISerializationContext context, StringConcatenation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns StringPrimitiveType
	 *     StringPrimitiveType returns StringPrimitiveType
	 *
	 * Constraint:
	 *     uniqueName=String0
	 */
	protected void sequence_StringPrimitiveType(ISerializationContext context, StringPrimitiveType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ElementsPackage.Literals.ELEMENT__UNIQUE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringPrimitiveTypeAccess().getUniqueNameString0ParserRuleCall_2_0(), semanticObject.getUniqueName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns SuperMethodClosureFilter
	 *     SuperMethodClosureFilter returns SuperMethodClosureFilter
	 *
	 * Constraint:
	 *     (negated=Boolean? targets+=[Element|EString] targets+=[Element|EString]* superMethod=[Method|EString] context=Context)
	 */
	protected void sequence_SuperMethodClosureFilter(ISerializationContext context, SuperMethodClosureFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SuperMethodInvocation
	 *     SuperMethodInvocation returns SuperMethodInvocation
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0 
	 *         exact=Boolean? 
	 *         elementAccessed=[Element|EString]? 
	 *         (properties+=Property properties+=Property*)? 
	 *         from=Statement? 
	 *         (args+=Statement args+=Statement*)?
	 *     )
	 */
	protected void sequence_SuperMethodInvocation(ISerializationContext context, SuperMethodInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchCaseBlock returns SwitchCaseBlock
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? default=Boolean? (properties+=Property properties+=Property*)? (statements+=Statement statements+=Statement*)?)
	 */
	protected void sequence_SwitchCaseBlock(ISerializationContext context, SwitchCaseBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns SwitchCaseStatementCount
	 *     SwitchCaseStatementCount returns SwitchCaseStatementCount
	 *
	 * Constraint:
	 *     (
	 *         negated=Boolean? 
	 *         min=Int0? 
	 *         max=Int0? 
	 *         targets+=[Element|EString] 
	 *         targets+=[Element|EString]* 
	 *         (cases+=SwitchCaseBlock cases+=SwitchCaseBlock*)?
	 *     )
	 */
	protected void sequence_SwitchCaseStatementCount(ISerializationContext context, SwitchCaseStatementCount semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SynchronizedBlock
	 *     SynchronizedBlock returns SynchronizedBlock
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0 
	 *         exact=Boolean? 
	 *         (properties+=Property properties+=Property*)? 
	 *         (bodyStatements+=Statement bodyStatements+=Statement*)? 
	 *         key=Statement?
	 *     )
	 */
	protected void sequence_SynchronizedBlock(ISerializationContext context, SynchronizedBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns TemplateFilter
	 *     TemplateFilter_Impl returns TemplateFilter
	 *
	 * Constraint:
	 *     (negated=Boolean? targets+=[Element|EString] targets+=[Element|EString]* targetTemplate=[Element|EString] context=Context)
	 */
	protected void sequence_TemplateFilter_Impl(ISerializationContext context, TemplateFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns TypedStatementFilter
	 *     TypedStatementFilter returns TypedStatementFilter
	 *
	 * Constraint:
	 *     (negated=Boolean? targets+=[Element|EString] targets+=[Element|EString]* type=[DataType|EString])
	 */
	protected void sequence_TypedStatementFilter(ISerializationContext context, TypedStatementFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VarAssignment
	 *     VarAssignment returns VarAssignment
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? variable=[Variable|EString]? (properties+=Property properties+=Property*)? assignment=Statement?)
	 */
	protected void sequence_VarAssignment(ISerializationContext context, VarAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VarDeclaration
	 *     VarDeclaration returns VarDeclaration
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? (properties+=Property properties+=Property*)? variable=Variable?)
	 */
	protected void sequence_VarDeclaration(ISerializationContext context, VarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VariableAccess
	 *     VariableAccess returns VariableAccess
	 *
	 * Constraint:
	 *     (uniqueName=String0 exact=Boolean? elementAccessed=[Element|EString]? (properties+=Property properties+=Property*)? from=Statement?)
	 */
	protected void sequence_VariableAccess(ISerializationContext context, VariableAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns VariableVector
	 *     Variable returns VariableVector
	 *     VariableVector returns VariableVector
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0 
	 *         exact=Boolean? 
	 *         name=String0? 
	 *         dimensions=Int0? 
	 *         type=[DataType|EString]? 
	 *         (properties+=Property properties+=Property*)? 
	 *         initialValue=Statement?
	 *     )
	 */
	protected void sequence_VariableVector(ISerializationContext context, VariableVector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Variable
	 *     Variable returns Variable
	 *     Variable_Impl returns Variable
	 *
	 * Constraint:
	 *     (
	 *         uniqueName=String0 
	 *         exact=Boolean? 
	 *         name=String0? 
	 *         type=[DataType|EString]? 
	 *         (properties+=Property properties+=Property*)? 
	 *         initialValue=Statement?
	 *     )
	 */
	protected void sequence_Variable_Impl(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
