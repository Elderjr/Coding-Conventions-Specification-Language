let violations: Set(ASTNode) = InfixExpression.allInstances()->union(Assignment.allInstances())->select(strConcat1 |
  --Scope Conditions
  ( (strConcat1.oclIsKindOf(Assignment) and strConcat1.oclAsType(Assignment).operator = AssignmentKind::PLUS_ASSIGN) or (strConcat1.oclIsKindOf(InfixExpression)) ) and
  --Statement Type Getter
  let lastStatement: OclAny = strConcat1->asOrderedSet()->closure(x |
    if x.oclIsKindOf(ParenthesizedExpression) then 
      x.oclAsType(ParenthesizedExpression).expression 
    else if x.oclIsKindOf(Assignment) then 
      x.oclAsType(Assignment).leftHandSide
    else
      x
    endif endif
  )->last() in
  let statementsToAnalyse: OrderedSet(OclAny) = if lastStatement.oclIsKindOf(InfixExpression) then
    lastStatement.oclAsType(InfixExpression)->asOrderedSet()->closure(statement | 
      if statement.oclIsKindOf(InfixExpression) then 
        statement.oclAsType(InfixExpression).extendedOperands->append(statement.oclAsType(InfixExpression).leftOperand)->append(statement.oclAsType(InfixExpression).rightOperand)
      else if statement.oclIsKindOf(ParenthesizedExpression) then 
        statement.oclAsType(ParenthesizedExpression).expression 
      else if statement.oclIsKindOf(Assignment) then 
        statement.oclAsType(Assignment).leftHandSide
      else 
        statement 
      endif endif endif
    )->select(statement | (not statement.oclIsKindOf(InfixExpression)) or (not statement.oclIsKindOf(ParenthesizedExpression)) or (not statement.oclIsKindOf(Assignment))
  ) 
  else
    lastStatement->asOrderedSet()
  endif in
  let strTmp: OrderedSet(ClassDeclaration) = ClassDeclaration.allInstances()->select(str | str.name = 'String' and str.oclContainer().oclAsType(Package).name = 'lang')->asOrderedSet() in
  let strClass: ClassDeclaration = if strTmp->size() > 0 then strTmp->first() else null endif in
  let strConcat1Type: OclAny = statementsToAnalyse->iterate(statement: OclAny; type: OclAny = null |
    if type.oclIsUndefined() then
      let typeTmp: OclAny = if statement.oclIsKindOf(ClassInstanceCreation) then
        statement.oclAsType(ClassInstanceCreation).type.type
      else if statement.oclIsKindOf(MethodInvocation) then
        if statement.oclAsType(MethodInvocation).method.oclIsKindOf(MethodDeclaration) and (not statement.oclAsType(MethodInvocation).method.oclAsType(MethodDeclaration).returnType.oclIsUndefined()) then
          statement.oclAsType(MethodInvocation).method.oclAsType(MethodDeclaration).returnType.type
        else
          null
        endif
      else if statement.oclIsKindOf(SingleVariableAccess) then
        if statement.oclAsType(SingleVariableAccess).oclAsType(SingleVariableAccess).variable.oclIsKindOf(SingleVariableDeclaration) then
          statement.oclAsType(SingleVariableAccess).variable.oclAsType(SingleVariableDeclaration).type.type
        else if statement.oclAsType(SingleVariableAccess).variable.oclIsKindOf(VariableDeclarationFragment) then
          statement.oclAsType(SingleVariableAccess).variable.oclAsType(VariableDeclarationFragment).variablesContainer.type.type
        else
         false
        endif endif
      else if statement.oclIsKindOf(StringLiteral) then
        strClass
      else if statement.oclIsKindOf(ArrayAccess) then
        let arrayAccesses: OrderedSet(OclAny) = statement.oclAsType(ArrayAccess)->asOrderedSet()->closure(x |
          if x.oclIsKindOf(ArrayAccess) then 
            x.oclAsType(ArrayAccess).array
          else if x.oclIsKindOf(ParenthesizedExpression) then
            x.oclAsType(ParenthesizedExpression).expression
          else if x.oclIsKindOf(Assignment) then 
            x.oclAsType(Assignment).leftHandSide
          else 
            x 
          endif endif endif
        ) in
        let arrayDimensions: Integer = if arrayAccesses->last().oclIsKindOf(SingleVariableAccess) then
          arrayAccesses->last().oclAsType(SingleVariableAccess).variable.extraArrayDimensions
        else if arrayAccesses->last().oclIsKindOf(MethodInvocation) and arrayAccesses->last().oclAsType(MethodInvocation).method.oclIsKindOf(MethodDeclaration) 
          and (not arrayAccesses->last().oclAsType(MethodInvocation).method.oclAsType(MethodDeclaration).returnType.oclIsUndefined()) then
          arrayAccesses->last().oclAsType(MethodInvocation).method.oclAsType(MethodDeclaration).returnType.type.oclAsType(ArrayType).dimensions
        else
         null
        endif endif in
        let arrayBaseType: OclAny = if arrayAccesses->last().oclIsKindOf(SingleVariableAccess) and arrayAccesses->last().oclAsType(SingleVariableAccess).variable.oclIsKindOf(SingleVariableDeclaration) then
          arrayAccesses->last().oclAsType(SingleVariableAccess).variable.oclAsType(SingleVariableDeclaration).type.type
        else if arrayAccesses->last().oclIsKindOf(SingleVariableAccess) and arrayAccesses->last().oclAsType(SingleVariableAccess).variable.oclIsKindOf(VariableDeclarationFragment) then
          arrayAccesses->last().oclAsType(SingleVariableAccess).variable.oclAsType(VariableDeclarationFragment).variablesContainer.type.type 
        else if arrayAccesses->last().oclIsKindOf(MethodInvocation) and arrayAccesses->last().oclAsType(MethodInvocation).method.oclIsKindOf(MethodDeclaration) 
          and (not arrayAccesses->last().oclAsType(MethodInvocation).method.oclAsType(MethodDeclaration).returnType.oclIsUndefined()) then
          arrayAccesses->last().oclAsType(MethodInvocation).method.oclAsType(MethodDeclaration).returnType.type.oclAsType(ArrayType).elementType.type
        else
          null
        endif endif endif in
        if (not arrayDimensions.oclIsUndefined()) and (not arrayBaseType.oclIsUndefined()) then
          if arrayDimensions = arrayAccesses->select(x | x.oclIsKindOf(ArrayAccess))->size() then
            arrayBaseType
          else
            null
          endif
        else
          null
        endif
      else
        null
      endif endif endif endif endif in if (lastStatement.oclIsKindOf(InfixExpression) and typeTmp = strClass) or (not lastStatement.oclIsKindOf(InfixExpression)) then
        typeTmp
      else
        null
      endif
    else
      type
    endif
  ) in (not strConcat1Type.oclIsUndefined()) and
  strConcat1Type = strClass and
  let strConcat1operands: OrderedSet(OclAny) = if strConcat1.oclIsKindOf(InfixExpression) then
    strConcat1.oclAsType(InfixExpression).extendedOperands->asOrderedSet()->append(strConcat1.oclAsType(InfixExpression).leftOperand)->append(strConcat1.oclAsType(InfixExpression).rightOperand)
  else if strConcat1.oclIsKindOf(Assignment) then
    strConcat1.oclAsType(Assignment).rightHandSide->asOrderedSet()
  else
   OrderedSet(OclAny){}
  endif endif in
  let strConcat1operandsWithoutParenthesis: OrderedSet(OclAny) = strConcat1operands->asOrderedSet()->closure(x | 
    if x.oclIsKindOf(ParenthesizedExpression) then x.oclAsType(ParenthesizedExpression).expression else x endif
  ) in
  strConcat1operandsWithoutParenthesis->exists(mInv2 | 
    let m3: OclAny = if mInv2.oclIsKindOf(MethodInvocation) then
      mInv2.oclAsType(MethodInvocation).method
    else if mInv2.oclIsKindOf(ClassInstanceCreation) then
      mInv2.oclAsType(ClassInstanceCreation).method
    else
      null
    endif endif in
    (not m3.oclIsUndefined())  and
    m3.oclIsKindOf(MethodDeclaration) and
    m3.oclAsType(MethodDeclaration).oclAsType(NamedElement).name = 'valueOf' and
    let c4: OclAny = m3.oclAsType(MethodDeclaration).oclContainer() in
    c4.oclIsKindOf(ClassDeclaration) and
    let c4Methods: OrderedSet(OclAny) = c4.oclAsType(ClassDeclaration).bodyDeclarations in
    c4Methods->exists(c4m3 | c4m3 = m3 and
    c4.oclAsType(ClassDeclaration).package->asOrderedSet()->closure(package)->reverse()->iterate(p: Package; fullName: String = '' |
      fullName.concat(p.name).concat('.')
    ).concat(c4.oclAsType(ClassDeclaration).name) = 'java.lang.String'
))) in
violations->collect(node: ASTNode | 
	let container: NamedElement = node->asOrderedSet()->closure(x |
		if x.oclIsKindOf(AbstractMethodDeclaration) or x.oclIsKindOf(AbstractTypeDeclaration) then
		  x
		else
		  x.oclContainer()
	    endif
	)->last() in 'Violation Found at '.concat(container.originalCompilationUnit.originalFilePath).concat(' on ').concat(container.name)
)->asSequence()
->append('#violations: '.concat(violations->size().toString()))
->append('#files: '.concat(violations.originalCompilationUnit.originalFilePath->asOrderedSet()->size().toString()))