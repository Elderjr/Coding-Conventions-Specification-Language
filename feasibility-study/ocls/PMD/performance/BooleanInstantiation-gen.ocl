
let violations: Set(ASTNode) = (
  ClassInstanceCreation.allInstances()->select(mInv1 |
    mInv1.type.type.oclAsSet()->exists(c2 | c2 <> mInv1 and 
      --Java Class Conditions
      c2.oclIsKindOf(ClassDeclaration) and
      c2.oclAsType(ClassDeclaration).package->asOrderedSet()->closure(package)->reverse()->iterate(p: Package; fullName: String = '' |
        fullName.concat(p.name).concat('.')
      ).concat(c2.oclAsType(BodyDeclaration).name) = 'java.lang.Boolean'  
  ))
->union(
    MethodInvocation.allInstances()->select(mInv1 |
      mInv1.method.oclAsSet()->exists(m2 | m2 <> mInv1 and 
        -- Method Conditions
        m2.name = 'valueOf' and
        m2.oclContainer().oclAsSet()->exists(c3 | c3 <> m2 and c3 <> mInv1 and 
          --Java Class Conditions
          (
            c3.oclIsKindOf(ClassDeclaration) and
            c3.oclAsType(ClassDeclaration).bodyDeclarations->includes(m2) and
            c3.oclAsType(ClassDeclaration).package->asOrderedSet()->closure(package)->reverse()->iterate(p: Package; fullName: String = '' |
              fullName.concat(p.name).concat('.')
            ).concat(c3.oclAsType(BodyDeclaration).name) = 'java.lang.Boolean'
          ) and
      mInv1.arguments->exists(e4 | e4 <> m2 and e4 <> mInv1 and e4 <> c3 and 
        (e4.oclIsKindOf(StringLiteral) or e4.oclIsKindOf(CharacterLiteral) or e4.oclIsKindOf(NumberLiteral) or e4.oclIsKindOf(BooleanLiteral))  
    ))))
  )
)
 in violations->collect(node: ASTNode | 
	let container: NamedElement = node->asOrderedSet()->closure(x |
		if x.oclIsKindOf(AbstractMethodDeclaration) or x.oclIsKindOf(AbstractTypeDeclaration) then
		  x
		else
		  x.oclContainer()
	    endif
	)->last() in 'Violation Found at '.concat(container.originalCompilationUnit.originalFilePath).concat(' on ').concat(container.name)
)->asSequence()
->append('#violations: '.concat(violations->size().toString()))
->append('#files: '.concat(violations.originalCompilationUnit.originalFilePath->asOrderedSet()->size().toString()))