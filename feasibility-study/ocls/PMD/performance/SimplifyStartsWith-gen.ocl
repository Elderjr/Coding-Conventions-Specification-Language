let violations: Set(ASTNode) = MethodInvocation.allInstances()->union(ClassInstanceCreation.allInstances())->select(mInv1 |
  let m2: OclAny = if mInv1.oclIsKindOf(MethodInvocation) then
    mInv1.oclAsType(MethodInvocation).method
  else if mInv1.oclIsKindOf(ClassInstanceCreation) then
    mInv1.oclAsType(ClassInstanceCreation).method
  else
    null
  endif endif in
  (not m2.oclIsUndefined()) and
  m2.oclIsKindOf(MethodDeclaration) and
  m2.oclAsType(MethodDeclaration).name = 'startsWith' and
  let c3: OclAny = m2.oclAsType(MethodDeclaration).oclContainer() in
  c3.oclIsKindOf(ClassDeclaration) and
  let c3Methods: OrderedSet(OclAny) = c3.oclAsType(ClassDeclaration).bodyDeclarations in
  c3Methods->exists(c3m2 | c3m2 = m2 and
  c3.oclAsType(ClassDeclaration).package->asOrderedSet()->closure(package)->reverse()->iterate(p: Package; fullName: String = '' |
    fullName.concat(p.name).concat('.')
  ).concat(c3.oclAsType(ClassDeclaration).oclAsType(BodyDeclaration).name) = 'java.lang.String' and
  let mInv1Args: OrderedSet(OclAny) = if mInv1.oclIsKindOf(MethodInvocation) then
    mInv1.oclAsType(MethodInvocation).arguments
  else if mInv1.oclIsKindOf(ClassInstanceCreation) then
    mInv1.oclAsType(ClassInstanceCreation).arguments
  else
    null
  endif endif in
  (not mInv1Args->oclIsUndefined()) and
  mInv1Args->exists(e4 | 
    (e4.oclIsKindOf(StringLiteral))
   and
  e4.oclAsType(StringLiteral).escapedValue.matches('"."')
))) in violations->collect(node: ASTNode | 
	let container: NamedElement = node->asOrderedSet()->closure(x |
		if x.oclIsKindOf(AbstractMethodDeclaration) or x.oclIsKindOf(AbstractTypeDeclaration) then
		  x
		else
		  x.oclContainer()
	    endif
	)->last() in 'Violation Found at '.concat(container.originalCompilationUnit.originalFilePath).concat(' on ').concat(container.name)
)->asSequence()
->append('#violations: '.concat(violations->size().toString()))
->append('#files: '.concat(violations.originalCompilationUnit.originalFilePath->asOrderedSet()->size().toString()))