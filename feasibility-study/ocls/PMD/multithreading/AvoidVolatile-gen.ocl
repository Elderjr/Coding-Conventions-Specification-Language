let violations: Set(ASTNode) = VariableDeclarationFragment.allInstances()->select(v1 |
  --Scope Conditions
  (not v1.originalCompilationUnit.oclIsUndefined()) and
  let c2: OclAny = v1.oclContainer().oclContainer() in (not c2.oclIsUndefined()) and
  (c2.oclIsKindOf(ClassDeclaration) or c2.oclIsKindOf(InterfaceDeclaration) or c2.oclIsKindOf(AnonymousClassDeclaration)) and
  let v1Modifier: Modifier = if v1.oclIsKindOf(VariableDeclarationFragment) and 
   v1.oclAsType(VariableDeclarationFragment).variablesContainer.oclIsKindOf(FieldDeclaration) then
    v1.oclAsType(VariableDeclarationFragment).variablesContainer.oclAsType(FieldDeclaration).modifier
  else if v1.oclIsKindOf(VariableDeclarationFragment) and
   v1.oclAsType(VariableDeclarationFragment).variablesContainer.oclIsKindOf(VariableDeclarationStatement) then
    v1.oclAsType(VariableDeclarationFragment).variablesContainer.oclAsType(VariableDeclarationStatement).modifier
  else if v1.oclIsKindOf(SingleVariableDeclaration) then
    v1.oclAsType(SingleVariableDeclaration).modifier
  else
    null
  endif endif endif in (not v1Modifier.oclIsUndefined()) and
  v1Modifier.volatile
) in
violations->collect(node: ASTNode | 
	let container: NamedElement = node->asOrderedSet()->closure(x |
		if x.oclIsKindOf(AbstractMethodDeclaration) or x.oclIsKindOf(AbstractTypeDeclaration) then
		  x
		else
		  x.oclContainer()
	    endif
	)->last() in 'Violation Found at '.concat(container.originalCompilationUnit.originalFilePath).concat(' on ').concat(container.name)
)->asSequence()
->append('#violations: '.concat(violations->size().toString()))
->append('#files: '.concat(violations.originalCompilationUnit.originalFilePath->asOrderedSet()->size().toString()))
