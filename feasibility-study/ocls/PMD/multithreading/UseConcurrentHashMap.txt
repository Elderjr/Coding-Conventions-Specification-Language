let violations: Set(ASTNode) = (
  VariableDeclarationFragment.allInstances()->select(var1 |
    --Context Conditions
    (not var1.oclIsKindOf(UnresolvedItem)) and
    let mapParameterizedType: ASTNode = var1.variablesContainer.type.type in
    mapParameterizedType <> null and
    mapParameterizedType.oclIsKindOf(ParameterizedType) and
    let mapInterface: ASTNode = mapParameterizedType.oclAsType(ParameterizedType).type.type in
    mapInterface <> null and
    (mapInterface.oclIsKindOf(InterfaceDeclaration)) and
    mapInterface.oclAsType(InterfaceDeclaration).package->asOrderedSet()->closure(package)->reverse()->iterate(p: Package; fullName: String = '' |
      fullName.concat(p.name).concat('.')
    ).concat(mapInterface.oclAsType(NamedElement).name) = 'java.util.Map' and
    let stmt2: ASTNode = var1.variablesContainer.fragments->asOrderedSet()->last().initializer in
    stmt2 <> null and
    stmt2.oclIsKindOf(ClassInstanceCreation) and
    let e3: ASTNode = stmt2.oclAsType(ClassInstanceCreation).type.type in
    e3 <> null and
    e3.oclIsKindOf(ParameterizedType) and
    let notAConcurrentHashMapClass: ASTNode = e3.oclAsType(ParameterizedType).type.type in
    notAConcurrentHashMapClass <> null and
    (notAConcurrentHashMapClass.oclIsKindOf(ClassDeclaration) or notAConcurrentHashMapClass.oclIsKindOf(AnonymousClassDeclaration))  and 
    --Filters Conditions
    not (
      let className: String = if notAConcurrentHashMapClass.oclIsKindOf(ClassDeclaration) then
        notAConcurrentHashMapClass.oclAsType(ClassDeclaration).name
      else if notAConcurrentHashMapClass.oclIsKindOf(AnonymousClassDeclaration) then
        notAConcurrentHashMapClass.oclAsType(AnonymousClassDeclaration).classInstanceCreation.type.type.oclAsType(AbstractTypeDeclaration).name
      else
        null
      endif endif in (not className.oclIsUndefined()) and
      let classPackage: Package = if notAConcurrentHashMapClass.oclIsKindOf(ClassDeclaration) then
        notAConcurrentHashMapClass.oclAsType(ClassDeclaration).package
      else if notAConcurrentHashMapClass.oclIsKindOf(AnonymousClassDeclaration) then
        notAConcurrentHashMapClass.oclAsType(AnonymousClassDeclaration).classInstanceCreation.type.type.oclAsType(AbstractTypeDeclaration).package
      else
        null
      endif endif in (not className.oclIsUndefined()) and
      classPackage->asOrderedSet()->closure(package)->reverse()->iterate(p: Package; fullName: String = '' |
        fullName.concat(p.name).concat('.')
      ).concat(className).matches('java\\.util\\.concurrent\\.ConcurrentHashMap')
    )
  )
  ->reject(node: ASTNode | node.originalCompilationUnit.oclIsUndefined())
  ->reject(node: ASTNode | node->closure(oclContainer())->exists(oclIsKindOf(Javadoc)))
  
) in
violations->asSequence()->collect(node: ASTNode | 
	let container: NamedElement = node->asOrderedSet()->closure(x |
        if x.oclIsKindOf(AbstractMethodDeclaration) or x.oclIsKindOf(AbstractTypeDeclaration) then
		  x
		else
		  x.oclContainer()
	    endif
	)->last() in if (not container.oclIsUndefined()) and (not container.originalCompilationUnit.oclIsUndefined()) then
      'Violation Found at '.concat(container.originalCompilationUnit.originalFilePath).concat(' on ').concat(container.name)
    else
      ''
    endif
)->asSequence()->select(violation | violation.size() > 0)
->append('#violations: '.concat(violations->size().toString()))
