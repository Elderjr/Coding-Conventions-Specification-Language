let violations: Set(ASTNode) = TypeAccess.allInstances()->select(threadAccess |
  --Context Conditions
  --Filters Conditions
  --Closure Filter
  let typeAccessClosure: ASTNode = threadAccess in
  let closureSet: OrderedSet(ASTNode) = typeAccessClosure.oclAsType(TypeAccess).type
  ->closure(node: ASTNode |
    if(node.oclIsKindOf(TypeAccess)) then
      node.oclAsType(TypeAccess).type
    else if (node.oclIsKindOf(ArrayType)) then
      node.oclAsType(ArrayType).elementType
    else if (node.oclIsKindOf(ParameterizedType)) then
      node.oclAsType(ParameterizedType).typeArguments->append(node.oclAsType(ParameterizedType).type)
    else
      null
    endif endif endif
  ) in
  closureSet->exists(threadOrInterface:ASTNode |
    (threadOrInterface.oclIsKindOf(ClassDeclaration) or threadOrInterface.oclIsKindOf(InterfaceDeclaration) or threadOrInterface.oclIsKindOf(AnonymousClassDeclaration)) and
  (
    --Closure Filter Context
    --Context Conditions
    --Filters Conditions
    let threadOrInterfacePackage: Package = if threadOrInterface.oclIsKindOf(ClassDeclaration) then
      threadOrInterface.oclAsType(ClassDeclaration).package
    else if threadOrInterface.oclIsKindOf(InterfaceDeclaration) then
      threadOrInterface.oclAsType(InterfaceDeclaration).package
    else
      null
    endif endif in (not threadOrInterfacePackage.oclIsUndefined()) and
    threadOrInterfacePackage->asOrderedSet()->closure(package)->reverse()->iterate(p: Package; fullName: String = '' |
      fullName.concat(p.name).concat('.')
    ).concat(threadOrInterface.oclAsType(NamedElement).name).matches('java\\.lang\\.(Thread|Runnable)')
    --End Closure Filter
  )) and
  not (
    -- Template Filter
    let typeAccessInv: ASTNode = threadAccess in
    typeAccessInv.oclIsKindOf(TypeAccess) and
    let methodInv1 : OclAny = typeAccessInv.oclContainer() in
    (methodInv1.oclIsKindOf(MethodInvocation)) and
    let stmtTmp: ASTNode = methodInv1.oclAsType(MethodInvocation).expression in
    stmtTmp = typeAccessInv
    -- End Template Filter
  )
)
->reject(node: ASTNode | node.oclContainer().oclAsType(ASTNode).originalCompilationUnit.oclIsUndefined())
->reject(node: ASTNode | node->closure(oclContainer())->exists(oclIsKindOf(Javadoc)))
->collect(node: ASTNode | node.oclContainer().oclAsType(ASTNode)) in
violations->asSequence()->collect(node: ASTNode | 
	let container: NamedElement = node->asOrderedSet()->closure(x |
        if x.oclIsKindOf(AbstractMethodDeclaration) or x.oclIsKindOf(AbstractTypeDeclaration) then
		  x
		else
		  x.oclContainer()
	    endif
	)->last() in if (not container.oclIsUndefined()) and (not container.originalCompilationUnit.oclIsUndefined()) then
      'Violation Found at '.concat(container.originalCompilationUnit.originalFilePath).concat(' on ').concat(container.name)
    else
      ''
    endif
)->asSequence()->select(violation | violation.size() > 0)
->append('#violations: '.concat(violations->size().toString()))
